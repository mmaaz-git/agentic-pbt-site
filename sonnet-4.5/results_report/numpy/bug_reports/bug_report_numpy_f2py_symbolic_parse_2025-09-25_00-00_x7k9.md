# Bug Report: numpy.f2py.symbolic.Expr - Parse/Tostring Round-trip Failure for Exponentiation

**Target**: `numpy.f2py.symbolic.Expr`
**Severity**: High
**Bug Type**: Logic
**Date**: 2025-09-25

## Summary

The `Expr.parse()` function incorrectly interprets the exponentiation operator `**` as multiplication followed by the dereference operator, breaking the round-trip property between `tostring()` and `parse()`.

## Property-Based Test

```python
import numpy.f2py.symbolic as symbolic
from hypothesis import given, strategies as st, settings

st_symbol_name = st.text(min_size=1, max_size=10, alphabet='abcdefghijklmnopqrstuvwxyz')

@st.composite
def st_simple_expr(draw):
    choice = draw(st.integers(min_value=0, max_value=2))
    if choice == 0:
        return symbolic.as_number(draw(st.integers(min_value=-1000, max_value=1000)))
    elif choice == 1:
        return symbolic.as_symbol(draw(st_symbol_name))
    else:
        left = symbolic.as_symbol(draw(st_symbol_name))
        right = symbolic.as_symbol(draw(st_symbol_name))
        return left * right

@given(st_simple_expr())
@settings(max_examples=500)
def test_expr_parse_tostring_roundtrip(expr):
    s = expr.tostring()
    parsed = symbolic.Expr.parse(s)
    assert parsed == expr
```

**Failing input**: `Expr(Op.FACTORS, {Expr(Op.SYMBOL, 'a'): 2})`

## Reproducing the Bug

```python
import numpy.f2py.symbolic as symbolic

expr = symbolic.as_symbol('a') * symbolic.as_symbol('a')
print(f'Original: {repr(expr)}')

s = expr.tostring()
print(f'tostring(): "{s}"')

parsed = symbolic.Expr.parse(s)
print(f'Parsed: {repr(parsed)}')

print(f'Round-trip successful: {parsed == expr}')
```

Output:
```
Original: Expr(Op.FACTORS, {Expr(Op.SYMBOL, 'a'): 2})
tostring(): "a ** 2"
Parsed: Expr(Op.FACTORS, {Expr(Op.SYMBOL, 'a'): 1, Expr(Op.DEREF, Expr(Op.INTEGER, (2, 4))): 1})
Round-trip successful: False
```

## Why This Is A Bug

1. **Expected behavior**: When `a * a` is converted to string as `"a ** 2"`, parsing it should recover the original expression `Expr(Op.FACTORS, {Expr(Op.SYMBOL, 'a'): 2})`

2. **Actual behavior**: The parser interprets `"a ** 2"` as `"a * *2"` (multiplication of `a` and dereferenced `2`), producing `Expr(Op.FACTORS, {Expr(Op.SYMBOL, 'a'): 1, Expr(Op.DEREF, Expr(Op.INTEGER, (2, 4))): 1})`

3. **Impact**: This breaks the fundamental round-trip property that `parse(expr.tostring()) == expr`, which is critical for any serialization/deserialization workflow. Users cannot reliably parse expressions that were generated by the symbolic expression system.

4. **Root cause**: The parser is treating `**` as two separate `*` operators instead of recognizing it as the exponentiation operator.

## Fix

The parser needs to recognize `**` as a single token for exponentiation before attempting to parse it as multiplication. This likely requires updating the tokenization or parsing logic in `symbolic.py` to handle `**` as a distinct operator with higher precedence than `*`.