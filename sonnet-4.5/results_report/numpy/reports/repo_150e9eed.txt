/home/npc/miniconda/lib/python3.13/site-packages/numpy/lib/_scimath_impl.py:491: RuntimeWarning: divide by zero encountered in power
  return nx.power(x, p)
/home/npc/miniconda/lib/python3.13/site-packages/numpy/lib/_scimath_impl.py:491: RuntimeWarning: invalid value encountered in power
  return nx.power(x, p)
/home/npc/pbt/agentic-pbt/worker_/62/repo.py:24: RuntimeWarning: overflow encountered in power
  numpy_result = np.power(x2, -2)
/home/npc/miniconda/lib/python3.13/site-packages/numpy/lib/_scimath_impl.py:491: RuntimeWarning: overflow encountered in power
  return nx.power(x, p)
scimath.power(-9.499558537778752e-188, -2) = (inf+nanj)
Has NaN in result: True
Result type: <class 'numpy.complex128'>
Result dtype: complex128

Testing with -1e-200:
scimath.power(-1e-200, -2) = (inf+nanj)
Has NaN: True

Comparing with numpy.power:
np.power(-1e-200, -2) = inf

Mathematical expectation:
(-1e-200)^(-2) = 1/((-1e-200)^2) = 1/(1e-400) = 1e+400 = inf
Since negative^even = positive, result should be positive infinity

Step-by-step trace:
1. Input: x=-1e-200, p=-2
2. After _fix_real_lt_zero: x=(-1e-200+0j)
3. x^2 = -0j
4. 1/(x^2) = division by -0j

Testing threshold for NaN occurrence:
scimath.power(-1.000000e-150, -2) = (9.999999999999999e+299+0j), has NaN: False
scimath.power(-1.000000e-155, -2) = (inf+nanj), has NaN: True
scimath.power(-1.000000e-160, -2) = (inf+nanj), has NaN: True
scimath.power(-1.000000e-170, -2) = (inf+nanj), has NaN: True
scimath.power(-1.000000e-180, -2) = (inf+nanj), has NaN: True
scimath.power(-1.000000e-190, -2) = (inf+nanj), has NaN: True
scimath.power(-1.000000e-200, -2) = (inf+nanj), has NaN: True
