=== Test 1: Different inputs produce identical outputs ===
py_version_hex(3, 0, 0)   = 0x3000000
py_version_hex(3, 256, 0) = 0x3000000
Same result? True

=== Test 2: Round-trip conversion fails ===
Original minor version: 256
Encoded hex value: 0x3000000
Extracted minor version: 0
Round-trip successful? False

=== Test 3: Multiple overflow cases ===
Input: (3, 255, 0)
  Hex result: 0x3ff0000
  Extracted: (3, 255, 0)

Input: (3, 256, 0)
  Hex result: 0x3000000
  Extracted: (3, 0, 0)
  ERROR: Data corruption detected!

Input: (3, 257, 0)
  Hex result: 0x3010000
  Extracted: (3, 1, 0)
  ERROR: Data corruption detected!

Input: (3, 512, 0)
  Hex result: 0x3000000
  Extracted: (3, 0, 0)
  ERROR: Data corruption detected!

Input: (256, 0, 0)
  Hex result: 0x100000000
  Extracted: (0, 0, 0)
  ERROR: Data corruption detected!

Input: (0, 0, 256)
  Hex result: 0x10000
  Extracted: (0, 1, 0)
  ERROR: Data corruption detected!

=== Test 4: Collision demonstration ===
py_version_hex(3, 0, 0) = 0x3000000
py_version_hex(3, 256, 0) = 0x3000000
py_version_hex(3, 512, 0) = 0x3000000
py_version_hex(3, 768, 0) = 0x3000000

All produce the same output? True

=== Test 5: Release level and serial overflow ===
Input level=15, serial=15
  Hex result: 0x30000ff
  Extracted level=15, serial=15

Input level=16, serial=0
  Hex result: 0x3000100
  Extracted level=0, serial=0
  ERROR: Data corruption in release fields!

Input level=0, serial=16
  Hex result: 0x3000010
  Extracted level=1, serial=0
  ERROR: Data corruption in release fields!

Input level=255, serial=255
  Hex result: 0x3000fff
  Extracted level=15, serial=15
  ERROR: Data corruption in release fields!

