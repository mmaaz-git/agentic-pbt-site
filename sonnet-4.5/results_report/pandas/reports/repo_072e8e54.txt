Testing pandas.api.types.infer_dtype with various scalar types

============================================================

1. PYTHON BUILT-IN SCALARS (These crash):

Python int           value=0          → ERROR: 'int' object is not iterable
Python float         value=1.5        → ERROR: 'float' object is not iterable
Python bool          value=True       → ERROR: 'bool' object is not iterable
Python complex       value=(1+2j)     → ERROR: 'complex' object is not iterable
None                 value=None       → ERROR: 'NoneType' object is not iterable

============================================================

2. SCALAR TYPES THAT WORK:

String               value='hello'         → string
Bytes                value=b'bytes'        → integer
NumPy int64          value=np.int64(5)     → integer
NumPy float64        value=np.float64(5.5) → floating

============================================================

3. THE SAME VALUES WRAPPED IN LISTS (All work):

Python int           value=[0] → integer
Python float         value=[1.5] → floating
Python bool          value=[True] → boolean
Python complex       value=[(1+2j)] → complex
None                 value=[None] → mixed

============================================================

4. VERIFYING SCALAR STATUS WITH pandas.api.types.is_scalar:

Python int           is_scalar=True
Python float         is_scalar=True
Python bool          is_scalar=True
Python complex       is_scalar=True
None                 is_scalar=True
String               is_scalar=True
Bytes                is_scalar=True
NumPy int64          is_scalar=True
NumPy float64        is_scalar=True

============================================================

CONCLUSION:
The function is documented to accept 'scalar' values but crashes on
common Python scalar types (int, float, bool, complex, None) while
working for some other scalars (str, bytes, numpy scalars).
