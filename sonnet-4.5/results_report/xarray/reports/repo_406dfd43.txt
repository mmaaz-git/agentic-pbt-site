Testing inverse_permutation with partial permutation:
Initial indices: [1]
N (size of output array): 2

First inverse (inv1): [-1  0]
Note: inv1[0] = -1 (sentinel value indicating position 0 not in original permutation)
      inv1[1] = 0 (element at position 0 in original goes to position 1)

Second inverse (inv2): [1 0]
Note: When inv1=[-1, 0] is used as input:
      The -1 is treated as a valid index by numpy (negative indexing)
      inv2[-1] gets set to 0 (i.e., inv2[1] = 0)
      inv2[0] gets set to 1

Expected result: [1] (should be involutive)
Actual result: [1 0]
Are they equal? False

Why this is wrong:
1. The function uses -1 as a sentinel value to mark 'not in permutation'
2. But it doesn't validate that input indices are non-negative
3. When -1 appears in input, numpy treats it as index from end (last element)
4. This breaks the mathematical property of involution for partial permutations
