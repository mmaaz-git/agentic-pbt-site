# Bug Report: django.core.checks.registry.CheckRegistry String Iteration Bug

**Target**: `django.core.checks.registry.CheckRegistry.run_checks()`
**Severity**: Medium
**Bug Type**: Logic
**Date**: 2025-09-25

## Summary

When a registered check function returns a string instead of a list of CheckMessage objects, `CheckRegistry.run_checks()` silently accepts the string and iterates over it character-by-character, violating the documented requirement that check functions must return a list.

## Property-Based Test

```python
from hypothesis import given, strategies as st
from django.core.checks.registry import CheckRegistry


@given(st.text(min_size=1))
def test_registry_check_returns_string_bug(error_string):
    registry = CheckRegistry()

    def bad_check(app_configs, **kwargs):
        return error_string

    registry.register(bad_check, "test")

    result = registry.run_checks()

    assert len(result) == len(error_string)
    assert result == list(error_string)


if __name__ == "__main__":
    # Run the property-based test
    import traceback

    try:
        test_registry_check_returns_string_bug()
        print("Test passed for multiple string inputs generated by Hypothesis")
        print("\nExample with 'error message':")

        # Show specific example
        registry = CheckRegistry()
        def bad_check(app_configs, **kwargs):
            return "error message"
        registry.register(bad_check, "test")
        result = registry.run_checks()
        print(f"Input string: 'error message'")
        print(f"Result: {result}")
        print(f"This demonstrates that strings are incorrectly split character-by-character")
    except Exception as e:
        print(f"Test failed with error: {e}")
        traceback.print_exc()
```

<details>

<summary>
**Failing input**: `"error message"`
</summary>
```
Test passed for multiple string inputs generated by Hypothesis

Example with 'error message':
Input string: 'error message'
Result: ['e', 'r', 'r', 'o', 'r', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e']
This demonstrates that strings are incorrectly split character-by-character
```
</details>

## Reproducing the Bug

```python
from django.core.checks.registry import CheckRegistry


# Create a CheckRegistry instance
registry = CheckRegistry()


# Define a bad check function that returns a string instead of a list
def bad_check(app_configs, **kwargs):
    return "error message"


# Register the bad check
registry.register(bad_check, "test")

# Run the checks
result = registry.run_checks()

# Print the results
print(f"Result: {result}")
print(f"Type of result: {type(result)}")
print(f"Length of result: {len(result)}")
print(f"Expected: A list of CheckMessage objects")
print(f"Actual: A list of individual characters from the string")
```

<details>

<summary>
String split into individual characters instead of error
</summary>
```
Result: ['e', 'r', 'r', 'o', 'r', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e']
Type of result: <class 'list'>
Length of result: 13
Expected: A list of CheckMessage objects
Actual: A list of individual characters from the string
```
</details>

## Why This Is A Bug

This behavior violates Django's documented contract in multiple ways:

1. **Documentation Mismatch**: The docstring in `CheckRegistry.register()` (line 38 of registry.py) explicitly states: "The function should receive **kwargs and return list of Errors and Warnings." Not "iterable" - specifically "list".

2. **Error Message Contradiction**: The error message at lines 92-93 states: "The function %r did not return a list. All functions registered with the checks registry must return a list." Yet the code at line 90 checks `isinstance(new_errors, Iterable)`, which accepts strings since strings are iterable in Python.

3. **Silent Type Violation**: The code accepts a string and processes it character-by-character via `errors.extend(new_errors)` at line 95, resulting in a list of individual characters instead of CheckMessage objects. This will cause confusing downstream errors when code expects CheckMessage objects with attributes like `level`, `msg`, etc.

4. **Breaks Expected Behavior**: Django check functions are meant to return structured error/warning objects, not raw strings. Accepting strings and splitting them character-by-character is clearly unintended behavior that makes debugging difficult.

## Relevant Context

The bug exists at line 90 of `/django/core/checks/registry.py` where the code checks if the return value is an `Iterable` instead of specifically a `list`. Since Python strings are iterable, they pass this check and get processed character-by-character when `errors.extend(new_errors)` is called at line 95.

This type safety issue could affect any Django application where a developer accidentally returns a string error message instead of properly wrapping it in a list of CheckMessage objects. The resulting character list would likely cause AttributeError exceptions downstream when the code tries to access CheckMessage properties.

Django documentation consistently shows check functions returning lists containing Error, Warning, Info, or Debug objects from `django.core.checks`. See: https://docs.djangoproject.com/en/stable/topics/checks/

## Proposed Fix

```diff
--- a/django/core/checks/registry.py
+++ b/django/core/checks/registry.py
@@ -87,7 +87,7 @@ class CheckRegistry:

         for check in checks:
             new_errors = check(app_configs=app_configs, databases=databases)
-            if not isinstance(new_errors, Iterable):
+            if isinstance(new_errors, str) or not isinstance(new_errors, Iterable):
                 raise TypeError(
                     "The function %r did not return a list. All functions "
                     "registered with the checks registry must return a list." % check,
```