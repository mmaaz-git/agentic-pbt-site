Documentation Analysis for numpy.f2py.capi_maps

After reviewing the source code and available documentation:

1. SOURCE CODE EXAMINATION:
   - The file numpy/f2py/capi_maps.py contains mapping dictionaries that translate between Fortran/C types and NumPy types
   - Line 73 shows: 'complex_long_double': 'NPY_CDOUBLE'
   - Line 59 shows: 'long_double': 'NPY_LONGDOUBLE'
   - Line 93 shows c2pycode_map has: 'complex_long_double': 'G' (which corresponds to NPY_CLONGDOUBLE)

2. NUMPY C API DOCUMENTATION:
   - NPY_CDOUBLE is a 128-bit/16-byte complex type made up of two NPY_DOUBLE values (64-bit each)
   - NPY_CLONGDOUBLE is a platform-specific complex type made up of two NPY_LONGDOUBLE values
   - NPY_CLONGDOUBLE provides higher precision than NPY_CDOUBLE on platforms where long double > double

3. PATTERN ANALYSIS:
   The mapping pattern shows consistent precision preservation:
   - float (32-bit) → NPY_FLOAT, complex_float → NPY_CFLOAT
   - double (64-bit) → NPY_DOUBLE, complex_double → NPY_CDOUBLE
   - long_double (≥64-bit) → NPY_LONGDOUBLE, complex_long_double → NPY_CDOUBLE (inconsistent!)

4. VERIFICATION:
   - NPY_CLONGDOUBLE is confirmed to exist in NumPy headers (ndarraytypes.h)
   - The c2pycode_map correctly uses 'G' for complex_long_double, which corresponds to NPY_CLONGDOUBLE
   - There's an inconsistency between c2capi_map (NPY_CDOUBLE) and c2pycode_map ('G' = NPY_CLONGDOUBLE)

5. DOCUMENTATION FINDINGS:
   - No explicit documentation found specifying that complex_long_double should map to NPY_CDOUBLE
   - The general pattern and consistency across other mappings suggests complex types should preserve precision
   - The c2pycode_map's use of 'G' (NPY_CLONGDOUBLE) suggests the intended mapping

CONCLUSION:
The documentation does not explicitly specify the mapping for complex_long_double, but the internal consistency of the code and the existence of NPY_CLONGDOUBLE strongly suggest that the current mapping to NPY_CDOUBLE is incorrect and should be NPY_CLONGDOUBLE to maintain precision consistency.