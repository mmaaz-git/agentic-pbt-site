## INVALID Considerations
**Why it might be INVALID:**
The behavior could be considered expected if single-element arrays were never intended to be supported by these functions. The documentation does state the formula "2*(m-1)" which mathematically produces 0 for m=1, so technically the code is doing exactly what the documentation says. Users could be expected to understand this mathematical implication and provide the n parameter explicitly.

**Why it might not be INVALID:**
The documentation never states that single-element arrays are unsupported. Single-element FFTs are mathematically valid operations - the FFT of a single element is just that element. The documentation explicitly states that "irfft(rfft(a), len(a)) == a" should work, but this fails for single-element arrays. Most users would reasonably expect the inverse function to work on any valid output from the forward function.

## WONTFIX Considerations
**Why it might be WONTFIX:**
Single-element FFTs are an extreme edge case that rarely occurs in practice. Most FFT applications involve analyzing signals with multiple data points. The workaround is trivial (just specify n=1), and the error message clearly indicates the problem. Fixing this might add unnecessary complexity to the code for a case that affects very few users.

**Why it might not be WONTFIX:**
This isn't just a cosmetic issue or poor error message - it's a complete failure of core functionality. The functions crash rather than returning a result. The round-trip property is fundamental to FFT operations, and it's broken for a valid input size. The fix is simple (adding max(1, ...) to the calculation) and wouldn't affect performance for normal cases.

## DOCUMENTATION_FIX Considerations
**Why it might be DOCUMENTATION_FIX:**
The documentation could be updated to explicitly state that single-element arrays require the n or s parameter to be specified. The formula "2*(m-1)" is documented, and users could be expected to understand its implications. Adding a note about this edge case would prevent confusion without changing the code behavior.

**Why it might not be DOCUMENTATION_FIX:**
The issue isn't that the documentation is unclear or missing information - it's that the code fails to handle a valid input case. The documentation states that irfft is the inverse of rfft, which implies it should work for all valid rfft outputs. Documenting a workaround for broken behavior doesn't fix the underlying problem that the inverse operation fails.

## FEATURE_REQUEST Considerations
**Why it might be FEATURE_REQUEST:**
Supporting single-element arrays could be viewed as adding new functionality that wasn't originally designed. The current implementation assumes arrays with at least 2 elements, and adding support for single elements would be extending the feature set. Users requesting this could be asking for enhanced functionality beyond the original design scope.

**Why it might not be FEATURE_REQUEST:**
This isn't asking for new functionality - it's asking for the existing functionality to work correctly. The functions already claim to be inverse operations, and single-element arrays are valid inputs to the forward transforms. This is fixing broken existing functionality, not adding something new.

## BUG Considerations
**Why it might be BUG:**
The functions fail to maintain the documented round-trip property for valid inputs. Single-element arrays are mathematically valid for FFT operations, and the forward transforms (rfft, rfft2, rfftn) handle them correctly. The inverse functions crash instead of returning the expected result. The error occurs because of an edge case in the default parameter calculation that produces an invalid value (0). The fix is straightforward and wouldn't affect other use cases.

**Why it might not be BUG:**
The documentation does specify the formula used for the default calculation, and technically the code is following that formula exactly. Users could argue this is working as documented, even if the result is unfortunate. The existence of a simple workaround might suggest this is more of a usage issue than a code defect.

## Overall consideration

Looking at the evidence, this appears to be a legitimate bug. The core issue is that the inverse FFT functions violate a fundamental mathematical property - that they should be the inverse of their corresponding forward transforms. When rfft successfully processes a single-element array but irfft fails to invert it without additional parameters, this breaks the expected behavior of inverse operations.

The documentation strongly supports this being a bug. It explicitly states that "irfft(rfft(a), len(a)) == a" should hold within numerical accuracy, but this fails for single-element arrays even when following the documented usage. The documentation never warns users that single-element arrays are unsupported or require special handling. Mathematically, the FFT of a single element is well-defined and should work.

While single-element FFTs might be considered an edge case, numpy is a fundamental scientific computing library where correctness matters. The proposed fix (using max(1, 2*(m-1))) is simple, safe, and maintains backward compatibility while fixing the edge case. This isn't about adding new functionality or clarifying documentation - it's about fixing functions that crash on valid inputs when they should return valid outputs. The round-trip property is essential for FFT operations, and breaking it for any valid input size is a clear bug.