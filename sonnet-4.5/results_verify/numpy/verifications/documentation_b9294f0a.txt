DOCUMENTATION ANALYSIS
======================

1. NUMPY DOCUMENTATION CLAIMS:

   numpy.char.upper():
   - States: "Return an array with the elements converted to uppercase. Calls str.upper() element-wise."
   - States: Returns "Output ndarray with same dtype as input"

   numpy.char.lower():
   - States: "Return an array with the elements converted to lowercase. Call str.lower() element-wise."
   - States: Returns "Output ndarray with same dtype as input"

2. PYTHON str.upper() AND str.lower() BEHAVIOR:
   - Python's documentation confirms these methods follow Unicode Standard case mapping
   - Unicode case mapping can produce strings of different lengths:
     * 'ß'.upper() → 'SS' (1 char → 2 chars)
     * 'İ'.lower() → 'i̇' (1 char → 2 chars with combining dot)
     * Ligatures expand: 'ﬁ' → 'FI' (1 char → 2 chars)

3. DOCUMENTATION CONTRADICTION:

   The NumPy documentation contains a fundamental contradiction:

   a) It claims to "call str.upper() element-wise"
   b) It also claims to return "same dtype as input"

   These two claims are incompatible when Unicode case mappings change string length.
   When str.upper('ß') returns 'SS', it cannot fit in dtype <U1, so NumPy cannot
   both call str.upper() AND preserve the input dtype.

4. WHAT THE DOCUMENTATION DOESN'T SAY:
   - No warning about potential truncation
   - No mention of Unicode case mapping that changes string length
   - No guidance on choosing appropriate dtype for Unicode text
   - No mention that the behavior differs from Python's str.upper()/lower()
   - No warning that data loss can occur silently

5. USER EXPECTATION vs REALITY:
   Based on "calls str.upper() element-wise", users reasonably expect:
   - nc.upper(['ß'])[0] should equal 'ß'.upper() → 'SS'

   But due to "same dtype as input":
   - nc.upper(['ß'])[0] actually returns 'S' (truncated)

CONCLUSION:
The documentation is misleading. It claims to call Python's str.upper()/lower()
element-wise, but the actual behavior diverges from Python's when the dtype cannot
accommodate the result. This discrepancy is not documented, leading to silent data
corruption.