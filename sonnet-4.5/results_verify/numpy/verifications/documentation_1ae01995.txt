DOCUMENTATION ANALYSIS: NumPy String Handling
=============================================

## Key Documentation Findings

### 1. numpy.str_ Scalar Type Documentation
From https://numpy.org/doc/stable/reference/arrays.scalars.html:

**CRITICAL FINDING**: The documentation explicitly states that `str_` (Unicode string type):
- "Strips trailing null codepoints"
- Example given: `np.str_("abc\x00")` becomes `'abc'`

This is DOCUMENTED BEHAVIOR, not an undocumented bug.

### 2. String Data Types Documentation
From https://numpy.org/doc/stable/user/basics.types.html:

Key points:
- NumPy uses fixed-width string arrays
- Strings are truncated or zero-padded to fit specified width
- "NumPy cannot distinguish between intentional trailing nulls and padding nulls"
- For precise null byte preservation, documentation recommends using unstructured void data type

### 3. bytes_ Type Documentation
The `bytes_` type also "strips trailing null bytes" according to documentation.

### 4. numpy.char Module Documentation
From https://numpy.org/doc/stable/reference/routines.char.html:
- Methods are "based on the methods in the Python string module"
- However, they operate on numpy.str_ types which have different behavior
- Module is considered "legacy" with recommendation to use numpy.strings instead

## Documentation Assessment

1. **Is the null-stripping behavior documented?** YES
   - Explicitly documented for numpy.str_ type
   - Clear example provided showing '\x00' being stripped

2. **Is the behavior clearly explained?** PARTIALLY
   - The scalar type documentation mentions it
   - But it's not prominently featured in numpy.array() or numpy.char documentation
   - Users might not expect this when coming from Python strings

3. **Is there a documented workaround?** YES
   - Documentation suggests using void dtype for preserving nulls
   - Though this is mentioned in a different section

## Conclusion

The trailing null character truncation is DOCUMENTED BEHAVIOR, not an undocumented bug. However:
- The documentation could be clearer and more prominent
- The behavior differs significantly from Python's string semantics
- Many users would not expect this behavior without reading detailed type documentation