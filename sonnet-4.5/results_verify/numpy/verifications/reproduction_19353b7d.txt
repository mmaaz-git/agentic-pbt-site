BUG REPRODUCTION RESULTS
========================

I successfully reproduced all four bugs described in the report:

1. IRFFT BUG:
   Input: np.array([1.0])
   Error: ValueError: Invalid number of FFT data points (0) specified.
   Cause: Default n = 2*(1-1) = 0
   Workaround works: np.fft.irfft(rfft_result, n=1) returns [1.]

2. IRFFT2 BUG:
   Input: np.array([[1.0]])
   Error: ValueError: Invalid number of FFT data points (0) specified.
   Cause: Same formula leads to n = 0
   Workaround works: np.fft.irfft2(rfft2_result, s=(1,1)) returns [[1.]]

3. IRFFTN BUG:
   Input: np.array([1.0])
   Error: ValueError: Invalid number of FFT data points (0) specified.
   Cause: Same formula leads to n = 0
   Workaround works: np.fft.irfftn(rfftn_result, s=(1,)) returns [1.]

4. HFFT BUG:
   Input: np.array([1.0+0j])
   Error: ValueError: Invalid number of FFT data points (0) specified.
   Cause: Default n = 2*(1-1) = 0
   Workaround works: np.fft.hfft(x_hermitian, n=1) returns [1.]

ROUND-TRIP PROPERTY TEST:
- For single-element array: irfft(rfft(x)) FAILS without specifying n
- With n=1 specified: Round-trip works correctly
- For 2-element array: irfft(rfft(x)) works perfectly without specifying n

HYPOTHESIS TESTING:
The property-based test confirmed:
- All single-element arrays (size=1) fail with the same error
- All arrays with size >= 2 work correctly
- The failure is consistent and reproducible
- The workaround (specifying n or s) consistently fixes the issue

TECHNICAL DETAILS:
- The error originates from numpy/fft/_pocketfft.py line 60
- The formula n = 2*(m-1) produces n=0 when m=1
- The FFT implementation correctly rejects n=0 as invalid
- Mathematically, FFT of a single element should be valid

The bug report's description is technically accurate and all provided test cases reproduce exactly as described.