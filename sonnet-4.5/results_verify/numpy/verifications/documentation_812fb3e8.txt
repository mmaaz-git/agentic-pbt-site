## Documentation Analysis for numpy.fft.irfft

### Key Documentation Points

1. **irfft Purpose**: Computes the inverse of rfft, converting frequency domain data back to real-valued time/spatial domain.

2. **Default n Parameter Behavior**:
   - Documentation states: When `n` is not specified, it defaults to `2*(m-1)` where `m` is the input length
   - This formula is explicitly documented

3. **Relationship with rfft**:
   - Documentation states: `irfft(rfft(a), len(a)) â‰ˆ a`
   - Note the need to explicitly pass `len(a)` to ensure correct reconstruction
   - rfft output size: `(n/2)+1` for even n, `(n+1)/2` for odd n

4. **Critical Issue with the Formula**:
   - For a 1-element input array to rfft, the output has 1 element
   - Using the documented formula `2*(1-1) = 0` for irfft without n parameter
   - The documentation's formula leads directly to n=0, which is invalid

5. **Round-trip Behavior**:
   - The documentation acknowledges that specifying the original signal length is necessary to avoid information loss
   - For odd-length arrays, irfft cannot determine the original size without explicit n
   - Example: both 3-element and 2-element arrays produce 2-element rfft outputs

6. **No Special Case for Single Elements**:
   - The documentation does not mention any special handling for single-element arrays
   - The formula `2*(m-1)` is presented without exceptions or edge cases

### Assessment

The documentation accurately describes the current behavior - the formula `2*(m-1)` is exactly what the code implements. However, this formula has a mathematical edge case for m=1 that produces an invalid value (n=0). The documentation does not warn about this edge case or suggest that single-element arrays require special handling.

The bug report correctly identifies that:
1. The behavior matches the documentation
2. The documented formula produces an invalid result for a valid input
3. There is a reasonable expectation that rfft->irfft should round-trip for all valid inputs when n is provided