DOCUMENTATION ANALYSIS

## numpy.char.upper Documentation

The numpy.char.upper documentation states:
1. "Calls str.upper element-wise" - This is the key claim
2. Returns an output array "of StringDType, bytes_ or str_ dtype, depending on input types"
3. The documentation shows examples but only with ASCII characters that don't expand

Key observation: The documentation does NOT mention:
- Any limitations with Unicode character expansion
- That the output dtype will match the input dtype size
- That truncation may occur
- Any special handling (or lack thereof) for characters that expand when uppercased

## Python str.upper Documentation

Python's str.upper():
1. Returns "a copy of the string with all the cased characters converted to uppercase"
2. Uses the uppercasing algorithm from section 3.13 of the Unicode Standard
3. Properly handles Unicode case expansion (confirmed by testing 'ß'.upper() == 'SS')

## Unicode Standard

The Unicode Standard recognizes that case mappings can result in character expansion:
- Some characters change length when case-mapped
- The standard has properties like "Changes_When_Uppercased"
- Case folding can convert single characters to multiple characters

## Critical Finding

The numpy.char.upper documentation claims it "Calls str.upper element-wise". This creates a reasonable expectation that:

1. Each element should undergo the same transformation as Python's str.upper()
2. The result should match what str.upper() produces

However, the implementation fails to honor this contract when:
- Unicode characters expand during uppercase conversion
- The output would require a larger dtype than the input

The documentation creates an implicit contract that numpy.char.upper will behave like str.upper for each element. Since str.upper correctly handles Unicode expansion (e.g., 'ß' -> 'SS'), users would reasonably expect numpy.char.upper to do the same.

## Conclusion

The documentation does not warn about or acknowledge the truncation behavior. Given that:
1. The function explicitly claims to call str.upper element-wise
2. Python's str.upper handles Unicode expansion correctly
3. The Unicode Standard recognizes character expansion in case conversion

The current behavior violates the documented contract and reasonable user expectations. The silent truncation without warning is particularly problematic as it leads to data corruption.