## Bug Reproduction Report

I have successfully reproduced the bug described in the report. Here are my findings:

### 1. Hypothesis Test Execution
- The provided Hypothesis test fails immediately when trying to pass a complex array to `numpy.fft.rfft`
- Error: `TypeError: ufunc 'rfft_n_odd' not supported for the input types`
- The test correctly identifies that rfft cannot handle complex input arrays

### 2. Simple Example Reproduction
- Test input: `np.array([1.0 + 2.0j, 3.0 + 4.0j])`
- Result: TypeError with message "ufunc 'rfft_n_even' not supported for the input types"
- The error occurs consistently for any complex input array

### 3. Control Test
- When using only the real part of the same array (`a.real`), rfft works correctly
- Input: `[1. 3.]` (float64)
- Output: `[4.+0.j -2.+0.j]` (complex128)

### 4. Technical Investigation
I examined the underlying ufunc types supported by rfft:
- `rfft_n_even.types`: ['dd->D', 'ff->F', 'gg->G']
- `rfft_n_odd.types`: ['dd->D', 'ff->F', 'gg->G']

These type signatures show:
- 'd' = float64, 'f' = float32, 'g' = float128
- 'D' = complex128, 'F' = complex64, 'G' = complex256
- **No complex input types are supported** (no 'F->?' or 'D->?' signatures)

### Conclusion
The bug is confirmed. The implementation raises a TypeError when given complex input, directly contradicting the documentation's claim that imaginary parts are "silently discarded". The underlying C-level ufuncs simply don't support complex input types.