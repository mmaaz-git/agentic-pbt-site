DOCUMENTATION ANALYSIS FOR numpy.matrixlib.defmatrix.matrix.I

SOURCE CODE DOCUMENTATION (from defmatrix.py lines 812-814):
The docstring for the matrix.I property states:
"If `self` is non-singular, `ret` is such that ``ret * self`` == ``self * ret`` == ``np.matrix(np.eye(self[0,:].size))`` all return ``True``."

IMPLEMENTATION BEHAVIOR (from defmatrix.py lines 838-843):
The actual implementation checks if the matrix is square (M == N):
- If square: uses numpy.linalg.inv (true inverse)
- If non-square: uses numpy.linalg.pinv (pseudoinverse)

MATHEMATICAL FACTS ABOUT PSEUDOINVERSE:
1. For a matrix A of shape (m, n), the pseudoinverse A+ has shape (n, m)
2. A * A+ produces an m×m matrix
3. A+ * A produces an n×n matrix
4. When m ≠ n, these products have different shapes and cannot both equal the same identity matrix

DOCUMENTATION PROBLEM:
The docstring claims that for non-singular matrices, both products (ret * self and self * ret) equal np.matrix(np.eye(self[0,:].size)), which is an n×n identity matrix. This is mathematically impossible for non-square matrices because:
- For a (2,3) matrix, the pseudoinverse is (3,2)
- inv * m produces a (3,3) matrix
- m * inv produces a (2,2) matrix
- The docstring claims both equal eye(3), but (2,2) ≠ (3,3) in shape

The term "non-singular" in the docstring is also misleading, as it typically applies only to square matrices. Non-square matrices cannot be "non-singular" in the traditional sense - they can only be full rank.

OFFICIAL NUMPY DOCUMENTATION:
The online documentation for matrix.I doesn't explicitly address non-square matrices but focuses on square invertible matrices. The documentation for numpy.linalg.pinv correctly describes the Moore-Penrose pseudoinverse properties, which are different from what the matrix.I docstring claims.