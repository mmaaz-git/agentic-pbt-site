Documentation Analysis
======================

## NumPy Documentation Review

I reviewed the official NumPy documentation for the affected functions:

### Function Documentation

1. **numpy.char.upper**:
   - Documentation states: "Return an array with the elements converted to uppercase. Calls str.upper element-wise."
   - Explicit claim: It calls Python's str.upper element-wise

2. **numpy.char.swapcase**:
   - Documentation states: "Calls str.swapcase element-wise"
   - Explicit claim: It calls Python's str.swapcase element-wise

3. **numpy.char.capitalize**:
   - Documentation states: "Calls str.capitalize element-wise"
   - Explicit claim: It calls Python's str.capitalize element-wise

4. **numpy.char.title**:
   - Documentation states: "Calls str.title element-wise"
   - Explicit claim: It calls Python's str.title element-wise

### Key Documentation Claims

ALL four functions explicitly state in their documentation that they call the corresponding Python str method "element-wise". This is a clear, unambiguous contract that these NumPy functions should produce the same results as their Python counterparts.

### String Type Limitations

From NumPy's dtype documentation:
- NumPy uses fixed-width string types (e.g., 'U5' for 5-character Unicode strings)
- The documentation explicitly states: "If a string is longer than the specified width, it gets truncated"
- This is a known and documented limitation of NumPy's string dtype system

### Documentation Gap

The critical issue is that while NumPy documents that:
1. These functions call Python's str methods element-wise (implying identical behavior)
2. String dtypes have fixed widths and truncate when exceeded

It does NOT document that:
- Case transformation functions may produce truncated results
- The functions don't actually call str methods when the result would exceed the dtype width
- Unicode characters that expand during case transformation will lose data

### Conclusion

The documentation creates a clear expectation that these functions behave identically to Python's str methods, but this is demonstrably false for certain Unicode characters. The functions do not "call str.upper element-wise" as documented - they call it and then truncate the result, which is fundamentally different behavior.