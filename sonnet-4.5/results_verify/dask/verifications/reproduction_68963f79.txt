## Reproduction Analysis

I have successfully reproduced the bug described in the report. Here are my findings:

### Test Results

1. **Property-based test**: The hypothesis test runs correctly and consistently demonstrates that:
   - `head()` method accepts an `npartitions` parameter without error
   - `tail()` method raises a TypeError when `npartitions` is provided
   - The error message is: "FrameBase.tail() got an unexpected keyword argument 'npartitions'"

2. **Direct reproduction**: The provided test code works as described:
   - `dask_df.head(10, npartitions=-1)` executes successfully and returns 10 rows
   - `dask_df.tail(10, npartitions=-1)` fails with TypeError as expected
   - `dask_df.tail(10)` without npartitions works correctly

3. **Method signatures inspection**:
   - `head()` signature: `(n: 'int' = 5, npartitions=1, compute: 'bool' = True)`
   - `tail()` signature: `(n: 'int' = 5, compute: 'bool' = True)`

   This confirms the asymmetry: `head()` has the `npartitions` parameter while `tail()` does not.

### Effect of the Bug

The bug has the following effects:

1. **API Asymmetry**: The `head()` and `tail()` methods, which are conceptually symmetric operations (getting first n vs last n rows), have different parameter interfaces.

2. **Limited Functionality**: Users cannot control how many partitions to search when getting the last n rows, while they can do so for the first n rows.

3. **Performance Implications**: Without the ability to specify npartitions, `tail()` only checks the last partition, which might not contain enough rows to satisfy the request, even when earlier partitions contain data.

The bug report accurately describes the issue and the reproduction code correctly demonstrates the problem.