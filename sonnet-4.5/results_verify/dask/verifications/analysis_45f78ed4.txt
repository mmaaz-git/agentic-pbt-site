BUG TRIAGE ANALYSIS FOR parse_bytes NEGATIVE VALUE ISSUE
=========================================================

EVALUATION FOR EACH CATEGORY:

1. BUG (Valid bug report)
-------------------------
ARGUMENTS FOR:
- The function accepts semantically incorrect inputs (negative byte sizes)
- Byte sizes inherently represent non-negative quantities of data
- This can cause downstream issues in functions like read_bytes where negative blocksize would break logic
- While not explicitly documented as invalid, negative byte sizes are nonsensical in this context
- The function name "parse_bytes" clearly indicates it's for parsing byte sizes, which cannot be negative
- All documented examples use positive values, suggesting negative values were not intended

ARGUMENTS AGAINST:
- Documentation doesn't explicitly prohibit negative values
- The function technically works with negative inputs (no crashes)
- Some might argue it's the caller's responsibility to validate inputs

2. INVALID (Incorrect bug report)
---------------------------------
ARGUMENTS FOR:
- Documentation doesn't explicitly state negative values are prohibited
- The function behaves consistently - it returns what you give it
- No explicit contract violation

ARGUMENTS AGAINST:
- Semantic meaning of "byte size" clearly implies non-negative values
- Just because documentation doesn't explicitly prohibit something doesn't mean it's valid
- Common sense dictates that byte sizes cannot be negative

3. WONTFIX (Trivial/uninteresting)
----------------------------------
ARGUMENTS FOR:
- Could be considered an edge case that rarely occurs in practice
- Users typically don't pass negative byte sizes
- Easy for callers to validate their own inputs

ARGUMENTS AGAINST:
- This is a utility function meant to parse and validate byte sizes
- Validation should happen at the parsing level, not require every caller to validate
- Can cause actual bugs in downstream code (e.g., read_bytes)

4. FEATURE_REQUEST (Not currently supported)
--------------------------------------------
ARGUMENTS FOR:
- Adding validation for negative values could be seen as a new feature
- Current behavior is consistent, just lacks this validation

ARGUMENTS AGAINST:
- This is fixing incorrect behavior, not adding new functionality
- The function already validates other aspects (invalid units)
- Rejecting invalid input is bug fixing, not feature addition

5. DOCUMENTATION_FIX (Documentation issue)
------------------------------------------
ARGUMENTS FOR:
- Could argue the documentation should explicitly state negative values are not allowed
- Documentation could be clearer about valid input ranges

ARGUMENTS AGAINST:
- The core issue is the code behavior, not the documentation
- Even with better docs, the function should still validate inputs
- Semantic meaning of byte sizes being non-negative is self-evident

FINAL ASSESSMENT:
----------------
This is clearly a BUG. The function parse_bytes is meant to parse byte size specifications, and byte sizes cannot be negative by definition. The function should validate its inputs and reject negative values, just as it rejects invalid unit specifications. The fact that negative values can cause issues in downstream code (like read_bytes) further confirms this is a bug that should be fixed.

The semantic incorrectness of negative byte sizes is fundamental - you cannot have -5MB of RAM or -100KB file size. This is not a documentation issue or a feature request, but a validation bug in the function.