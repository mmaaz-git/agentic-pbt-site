## Documentation Analysis for dask.diagnostics.ResourceProfiler

Based on reviewing the source code and available documentation:

### What ResourceProfiler Does
According to the docstring in the code (lines 122-159 of profile.py), ResourceProfiler is "A profiler for resource use" that records the following each timestep:
1. Time in seconds since the epoch
2. Memory usage in MB
3. % CPU usage

### How It Works
The ResourceProfiler uses a background process (`_Tracker` class) to monitor resource usage. The documentation states that "when used as a context manager data will be collected throughout the duration of the enclosed block."

### Key Implementation Details from the Code
1. The `_Tracker` class (lines 234-291) is a background Process that tracks resource usage
2. It uses psutil to monitor the parent process and its children
3. The `_update_pids` method (lines 250-253) is supposed to return a list of processes to monitor
4. The tracker process monitors both the parent process and its children, filtering out zombie processes

### What the Documentation DOESN'T Specify
The documentation does not explicitly state:
- Whether the tracker process itself should be included or excluded from monitoring
- The exact behavior of how PIDs should be filtered
- Whether monitoring should include the monitoring process itself
- The specific type expectations for the `pid` parameter in `_update_pids`

### Intent Based on Context
Looking at the code logic:
- Line 261: `pid = current_process()` gets the current process object
- Line 271: This `pid` is passed to `_update_pids(pid)`
- Line 252: The comparison `p.pid != pid` suggests the intent is to exclude the tracker process from monitoring

The natural expectation would be that a resource profiler should NOT include its own resource usage in the measurements, as that would distort the actual resource usage of the code being profiled. However, this is not explicitly documented.

### Conclusion
The documentation does not explicitly specify whether the tracker process should be included or excluded from resource monitoring. The behavior must be inferred from the code structure and common sense about what a profiler should measure.