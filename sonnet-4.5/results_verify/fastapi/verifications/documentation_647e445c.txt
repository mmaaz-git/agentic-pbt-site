## Documentation Analysis

### Function Documentation

The `jsonable_encoder` function's docstring states:
- **Purpose**: "Convert any object to something that can be encoded in JSON."
- **Use Case**: "This is used internally by FastAPI to make sure anything you return can be encoded as JSON before it is sent to the client."
- **Additional Use**: "You can also use it yourself, for example to convert objects before saving them in a database that supports only JSON."

### Key Documentation Points

1. **Broad Promise**: The function promises to handle "any object" and convert it to something JSON-encodable. This is a very broad contract.

2. **No Exclusions Mentioned**: The documentation does not mention any restrictions on dictionary key types or that tuple keys are unsupported.

3. **Parameters Documented**: All parameters are well-documented, focusing on Pydantic model handling, but none mention dictionary key type restrictions.

4. **FastAPI Tutorial**: The tutorial documentation emphasizes that `jsonable_encoder` converts complex types to JSON-compatible formats, handling Pydantic models, datetime objects, and ensuring nested values are JSON-compatible.

### JSON Specification Context

The JSON specification (RFC 7159) requires that object keys must be strings. Python's `json.dumps()` handles this by:
- Converting basic types (int, float, bool, None) to strings automatically
- Rejecting non-basic types like tuples with a TypeError

### Documentation Gap

The documentation does not specify:
1. How dictionary keys are handled when they are not strings
2. That tuple keys will cause a crash
3. What the expected behavior should be for non-string dictionary keys

### Conclusion

The documentation sets an expectation that `jsonable_encoder` will handle "any object" and convert it to something JSON-encodable. A dictionary with tuple keys is a valid Python object, and users would reasonably expect either:
1. The function to handle it gracefully (e.g., by converting tuple keys to strings)
2. The function to raise a clear, descriptive error about unsupported key types
3. The documentation to explicitly state which key types are supported

The current behavior (crashing with "unhashable type: 'list'") violates the documented contract and provides a confusing error message that doesn't clearly indicate the actual problem (tuple keys in dictionaries).