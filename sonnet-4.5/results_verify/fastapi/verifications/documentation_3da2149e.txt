DOCUMENTATION ANALYSIS
======================

1. RFC 7230 (HTTP/1.1 Message Syntax and Routing):
   - Section 3.2 discusses header field parsing
   - The RFC explains how multiple header fields can be combined with commas
   - FINDING: RFC 7230 does NOT explicitly specify how to handle empty values in
     comma-separated lists (consecutive commas, trailing commas)
   - The specification focuses on the mechanism of combining headers rather than
     detailed parsing rules for malformed lists

2. CORS Specification (W3C):
   - Checked W3C CORS specification (https://www.w3.org/TR/2020/SPSD-cors-20200602/)
   - The spec defines Access-Control-Request-Headers using ABNF notation
   - FINDING: The specification does NOT provide explicit guidance on handling
     empty values, trailing commas, or consecutive commas
   - It only mentions that if "parsing failed", the request should be terminated

3. MDN Documentation (Access-Control-Request-Headers):
   - States the header contains "a sorted list of unique, comma-separated, lowercase HTTP headers"
   - Example format: "Access-Control-Request-Headers: content-type,x-pingother"
   - FINDING: Does not specify behavior for empty values or malformed lists

4. Starlette Documentation:
   - Documents the CORSMiddleware configuration options
   - Explains allow_headers parameter and behavior
   - FINDING: Does not specify how malformed header lists should be handled

CONCLUSION:
The documentation does NOT explicitly specify how to handle empty values in comma-separated
header lists. However, there are two important considerations:

1. PRINCIPLE OF ROBUSTNESS: The general principle in network protocols is to be
   "conservative in what you send, liberal in what you accept" (Postel's Law).
   Rejecting requests due to trailing commas or consecutive commas violates this principle.

2. COMMON PRACTICE: Most HTTP parsers ignore empty values in comma-separated lists
   as they don't represent meaningful data. This is the expected behavior even if not
   explicitly documented.

3. PRACTICAL IMPACT: Real-world HTTP clients and proxies may introduce such formatting
   issues, and rejecting these requests creates unnecessary compatibility problems.

The lack of explicit documentation means this is somewhat of a gray area, but the
current behavior is overly strict and goes against common HTTP parsing practices.