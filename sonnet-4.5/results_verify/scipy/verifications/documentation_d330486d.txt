Documentation Findings for scipy.optimize Root-Finding Methods
==============================================================

After reviewing the official scipy documentation and searching for related information, here are my findings:

1. DOCUMENTED PRECONDITIONS FOR ROOT-FINDING METHODS

All bracketing methods (bisect, brentq, brenth, ridder) in scipy.optimize have clear and consistent documentation stating:
- The function f must be continuous
- f(a) and f(b) MUST have opposite signs
- The interval [a, b] must bracket a root (i.e., contain a sign change)

2. DOCUMENTED ERROR BEHAVIOR

The Python API documentation and actual behavior shows:
- When f(a) and f(b) have the same sign, a ValueError is raised
- The specific error message is: "f(a) and f(b) must have different signs"
- This is consistent across all bracketing methods (bisect, brentq, brenth, ridder)

3. CYTHON API DOCUMENTATION

The _zeros.loop_example function documentation states:
- It is an "Example of Cython optimize zeros functions with map"
- It takes method name, arguments, bounds xa/xb, tolerances, and max iterations
- Returns "the root for each of the values of `a0`"
- The documentation does NOT specify what happens when f(xa) and f(xb) have the same sign
- There is NO documented error handling or exception behavior

4. RELATIONSHIP BETWEEN PYTHON AND CYTHON APIs

The Cython API (_zeros.loop_example) appears to be a lower-level interface that:
- Provides direct access to the underlying C/Cython implementations
- Is primarily intended for performance when calling the function multiple times
- Does not document any error handling for invalid inputs

5. KEY OBSERVATION

The documentation for the Cython API does not explicitly state:
- That it enforces the same preconditions as the Python API
- How it handles error conditions
- Whether it raises exceptions or returns special values for invalid inputs

However, given that:
- These are mathematical root-finding algorithms that fundamentally require sign changes
- The Python API explicitly enforces this requirement with ValueError
- The underlying algorithms (bisection, Brent's method, etc.) mathematically require opposite signs

It is reasonable to expect the Cython API should either:
a) Raise an error like the Python API, OR
b) Return an empty result/special error value to indicate failure

The current behavior of returning 0.0 (which is not in the interval and not a root) appears to be an unintended consequence of missing input validation rather than documented behavior.