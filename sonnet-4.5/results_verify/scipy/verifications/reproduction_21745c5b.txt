REPRODUCTION ANALYSIS
=====================

I successfully reproduced the bug report's findings. Here are the key observations:

1. Parameter Comparison Test:
   - The hypothesis test correctly identifies that split() has a 'regex' parameter
   - The test confirms that rsplit() lacks the 'regex' parameter
   - split() parameters: {'regex', 'self', 'n', 'pat', 'expand'}
   - rsplit() parameters: {'pat', 'expand', 'n', 'self'}
   - The assertion fails as expected when checking for 'regex' in rsplit_params

2. Functional Behavior Test:
   - split('.', regex=True) treats '.' as a regex metacharacter (matches any character), resulting in empty strings: ['', '', '', '', '', '', '', '']
   - split('.', regex=False) treats '.' as a literal character, correctly splitting: ['a', 'b', 'c', 'd']
   - rsplit('.') always treats '.' as a literal character, producing: ['a', 'b', 'c', 'd']
   - Attempting to use rsplit('.', regex=False) raises TypeError: "StringMethods.rsplit() got an unexpected keyword argument 'regex'"

3. Additional Testing:
   - rsplit() consistently treats all patterns as literal strings
   - Patterns like '|' (regex OR operator) and '.*' (regex pattern) are treated as literal strings by rsplit()
   - split() with regex=True interprets these as regex patterns
   - split() with regex=False treats them as literals (matching rsplit() behavior)

The bug report accurately describes the issue: rsplit() lacks the regex parameter that split() has, forcing rsplit() to always treat patterns as literal strings. This creates an API inconsistency between two closely related methods that are documented as mirror operations.