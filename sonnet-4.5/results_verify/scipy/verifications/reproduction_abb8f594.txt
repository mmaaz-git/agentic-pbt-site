## Reproduction Analysis

I have successfully reproduced the bug reported in scipy.integrate.simpson when dealing with duplicate x values.

### Test Results:

1. **Hypothesis test with failing input (x=[1.0, 1.0, 2.0], y=[1.0, 1.0, 1.0])**:
   - simpson result: 0.6666666666666666
   - Expected: 1.0 (based on integral of constant = c*(b-a) = 1.0*(2.0-1.0))
   - Error: -0.333...
   - trapezoid correctly returns: 1.0

2. **Additional test cases confirmed**:
   - x=[0.0, 0.0, 1.0], y=[2.0, 2.0, 2.0]: simpson=1.333, expected=2.0, trapezoid=2.0 ✓
   - x=[0.0, 0.0, 0.0, 1.0], y=[5.0, 5.0, 5.0, 5.0]: simpson=1.667, expected=5.0, trapezoid=5.0 ✓
   - x=[1.0, 2.0, 2.0], y=[3.0, 3.0, 3.0]: simpson=2.0, expected=3.0, trapezoid=3.0 ✓

3. **Control case (no duplicates)**:
   - x=[0.0, 1.0, 2.0], y=[3.0, 3.0, 3.0]: simpson=6.0, expected=6.0 ✓
   - This confirms simpson works correctly when there are no duplicate x values

### Key Observations:

1. The bug is 100% reproducible with duplicate x values (zero-width intervals)
2. simpson consistently returns incorrect results when x contains duplicates
3. trapezoid handles the same cases correctly, returning the mathematically expected value
4. The issue only occurs with duplicate x values; normal spacing works fine
5. The error magnitude varies but is always present with duplicates

### Mathematical Expectation:

For a constant function y=c, the integral over [a,b] should equal c*(b-a) regardless of sampling points. This is a fundamental property of integration that should hold even with duplicate x values (which represent multiple samples at the same location).

The bug is confirmed and reproducible.