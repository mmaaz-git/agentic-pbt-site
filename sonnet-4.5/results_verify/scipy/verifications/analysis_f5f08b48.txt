## INVALID Considerations
**Why it might be INVALID:**
The documented behavior of irfft explicitly states that when n is not given, it defaults to 2*(m-1). For a single-element input, this mathematically results in n=0, which is invalid. The function is behaving exactly as documented - it follows its documented formula and raises an error when that formula produces an invalid value. Users can deduce from the documentation that single-element arrays require explicit n parameter.

**Why it might not be INVALID:**
The expectation that irfft(rfft(x)) should work for any valid input x is reasonable, especially since rfft accepts single-element arrays without issue. The documentation doesn't explicitly warn about this edge case, and the functions are described as inverses of each other, which implies they should round-trip successfully.

## WONTFIX Considerations
**Why it might be WONTFIX:**
Single-element FFTs are an extremely rare edge case in practice. The FFT is typically used for signal processing where single-element signals are meaningless. The workaround is trivial (just pass n=1), and changing the default behavior could break backward compatibility or introduce other edge cases. The current behavior is mathematically consistent with the documented formula.

**Why it might not be WONTFIX:**
The error message is genuinely unhelpful - it says "Invalid number of data points (0) specified" without explaining why n became 0 or how to fix it. This is a poor user experience that could easily be improved with a better error message. The issue affects a basic expectation of inverse functions working together.

## DOCUMENTATION_FIX Considerations
**Why it might be DOCUMENTATION_FIX:**
The documentation correctly describes the default n calculation as 2*(m-1), and the code follows this exactly. The real issue is that the documentation doesn't warn users about edge cases or provide examples with single-element arrays. Adding a note about single-element arrays requiring explicit n parameter would prevent confusion without changing any code behavior.

**Why it might not be DOCUMENTATION_FIX:**
The code itself has a genuine usability issue - it crashes on valid input that its inverse function accepts. This is more than a documentation problem; it's a design flaw in the default parameter calculation. Simply documenting the limitation doesn't fix the poor user experience.

## FEATURE_REQUEST Considerations
**Why it might be FEATURE_REQUEST:**
Supporting single-element array round-trips isn't currently a feature of the library when using default parameters. Adding special-case handling for single-element inputs would be a new feature that extends the current functionality. The current behavior follows the documented formula precisely, so changing it would be adding new capability rather than fixing broken behavior.

**Why it might not be FEATURE_REQUEST:**
The ability to round-trip FFT operations is a fundamental expectation, not a new feature. The rfft function already supports single-element arrays, so irfft should handle their output. This is fixing incomplete functionality rather than adding something entirely new.

## BUG Considerations
**Why it might be BUG:**
The functions rfft and irfft are described as inverses, yet irfft(rfft(x)) fails for valid inputs that rfft accepts. This violates the principle of least surprise and the mathematical expectation of inverse operations. The error occurs silently due to an edge case in the default parameter calculation, not because single-element arrays are inherently unsupported. The cryptic error message provides no guidance on the solution.

**Why it might not be BUG:**
The function behaves exactly as documented - the default n formula is clearly stated as 2*(m-1), and this formula correctly produces 0 for m=1. The documentation doesn't promise that the default parameters will always work for round-trips. Users who need specific behavior should read the documentation and provide appropriate parameters. The error is a natural consequence of the documented formula, not a deviation from specified behavior.

## Overall Consideration

After careful analysis, this appears to be primarily a DOCUMENTATION_FIX issue. The code is behaving exactly as documented - the default n parameter is calculated as 2*(m-1), which mathematically results in 0 for single-element inputs. The documentation clearly states this formula, and the code faithfully implements it. While the error is unfortunate, it's a predictable consequence of the documented behavior.

The key factors supporting DOCUMENTATION_FIX are: (1) The code follows its documented specification precisely, (2) Single-element FFTs are an extreme edge case with little practical value, (3) A simple workaround exists (passing n=1 explicitly), and (4) The main issue is that users aren't warned about this edge case in the documentation. The error message could also be improved to guide users to the solution, but this is also fundamentally a documentation/communication issue.

While there's an argument for this being a BUG due to the inverse function relationship, the fact that the behavior matches the documented specification weighs heavily against calling it a bug. The scipy library has chosen a specific default parameter calculation, documented it clearly, and implemented it correctly. The issue is that this choice has an unfortunate edge case that should be better documented, not that the implementation deviates from its specification.