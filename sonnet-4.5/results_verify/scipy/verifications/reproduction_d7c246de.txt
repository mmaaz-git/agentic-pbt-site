REPRODUCTION OF BUG REPORT
=========================

Bug Claim: The bracketing root-finding methods (bisect, ridder, brenth, brentq) under-report
the actual number of function evaluations by 2, not counting the initial f(a) and f(b) evaluations.

Test Environment:
- Python 3.13
- SciPy 1.16.2

Reproduction Steps:
1. Ran the provided hypothesis test - it PASSES without any assertion errors
2. Ran the manual reproduction example with modifications to track calls accurately

Key Finding: The bug report appears to be INCORRECT.

Test Results for bisect:
- When bisect(f, 0.0, 2.0) is called for f(x) = x - 1.5
- Actual function calls made by bisect: 4
  - Call 1: f(0.0) = -1.5  [initial bracket check]
  - Call 2: f(2.0) = 0.5   [initial bracket check]
  - Call 3: f(1.0) = -0.5  [bisection iteration]
  - Call 4: f(1.5) = 0.0   [found root]
- Reported function_calls: 4
- NO DISCREPANCY - the counts match exactly

Test Results for other methods:
- ridder: 4 actual calls, 4 reported (match)
- brenth: 3 actual calls, 3 reported (match)
- brentq: 3 actual calls, 3 reported (match)

Analysis of Bug Report:
The bug report's example output shows 6 calls with duplicates of f(1.5), which does not match
the actual behavior observed. The report claims bisect makes calls that aren't counted, but
testing shows that:
1. bisect DOES evaluate f(a) and f(b) internally
2. These evaluations ARE included in the function_calls count
3. The hypothesis test provided actually PASSES when run

The hypothesis test logic that supposedly demonstrates the bug:
1. Calls f(a) and f(b) to verify bracketing (2 calls)
2. Resets the counter to 0
3. Calls bisect which internally calls f(a) and f(b) again plus iterations
4. The test expects these to match, and they DO match

Conclusion: Cannot reproduce the claimed bug. All bracketing methods correctly report the total
number of function evaluations including the initial bracket checks.