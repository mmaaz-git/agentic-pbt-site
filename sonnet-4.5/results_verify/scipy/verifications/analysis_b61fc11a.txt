BUG CLASSIFICATION ANALYSIS
===========================

I will analyze this bug report against each possible classification:

BUG (Valid Bug Report)
----------------------
STRONG EVIDENCE FOR:
- The documentation explicitly promises "easier round-trip load and save"
- Data corruption occurs: 0.+infj becomes nan+infj during save/load
- Complex numbers with 0+infj are valid IEEE 754 values
- The issue is in core functionality (data preservation)
- Silent data corruption is a serious bug
- The fix is straightforward and addresses a clear implementation flaw
- RuntimeWarning indicates the code knows something is wrong

INVALID (Incorrect Report)
--------------------------
EVIDENCE AGAINST:
- The bug is real and reproducible
- The documentation supports the expectation of round-trip preservation
- Complex infinity values are valid in NumPy/Python

NO EVIDENCE FOR THIS CLASSIFICATION

WONTFIX (Trivial/Uninteresting)
--------------------------------
EVIDENCE AGAINST:
- Data corruption is not trivial
- Complex infinity values occur in scientific computing
- Silent corruption could affect research results
- The fix is simple and low-risk

WEAK CASE: Could argue format='4' is legacy, but it's still officially supported

FEATURE_REQUEST (Not Currently Supported)
------------------------------------------
EVIDENCE AGAINST:
- Round-trip preservation is already documented as a feature
- Complex numbers are already supported
- This is fixing broken existing functionality, not adding new

NO EVIDENCE FOR THIS CLASSIFICATION

DOCUMENTATION_FIX (Docs Wrong About Code)
------------------------------------------
WEAK EVIDENCE FOR:
- Could document that complex infinity doesn't round-trip correctly
- Could add warning about format='4' limitations

EVIDENCE AGAINST:
- The documentation's promise of round-trip is reasonable
- The code is buggy, not the documentation
- Fixing the code is better than documenting the limitation

FINAL ASSESSMENT
----------------
This is clearly a BUG. The code has a demonstrable flaw in handling complex
infinity values that causes data corruption during what should be a lossless
round-trip operation. The documentation promises this functionality, the values
are mathematically valid, and the corruption is silent. The implementation uses
a problematic operation (inf * 1j) that produces NaN, which is a clear bug
that should be fixed rather than documented or ignored.