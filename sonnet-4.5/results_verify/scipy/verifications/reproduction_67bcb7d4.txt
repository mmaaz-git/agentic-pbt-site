## Bug Reproduction Results

### Hypothesis Test
The hypothesis test from the bug report fails as expected. When running:
```python
@given(st.integers())
def test_find_with_integer_should_handle_gracefully(num):
    result = sc.find(num)
    assert isinstance(result, list)
```

Every integer input causes an `AttributeError: 'int' object has no attribute 'lower'`.

### Direct Reproduction
The specific example `sc.find(123)` does indeed produce:
```
AttributeError: 'int' object has no attribute 'lower'
```

This matches exactly what the bug report claims.

### Extended Testing
Testing with various non-string types all produce the same error:
- Integers (0, 42): AttributeError
- Float (3.14): AttributeError
- List ([], [1,2,3]): AttributeError
- Dict ({}): AttributeError
- Boolean (True, False): AttributeError

All fail with the same pattern: `'<type>' object has no attribute 'lower'`

### Valid Cases Work Correctly
- `sc.find(None)`: Returns all 355 constants (correct behavior)
- `sc.find("electron")`: Returns 54 matching constants (correct)
- `sc.find("")`: Returns all 355 constants (correct)
- `sc.find("ELECTRON")`: Returns 54 matching constants (correct, case-insensitive)

### Technical Analysis
The error occurs at line 2254 in the implementation:
```python
if sub.lower() in key.lower()
```

When `sub` is not a string, it doesn't have a `.lower()` method, causing the AttributeError.

### Key Observation
The function's type hint is `sub: str | None = None`, which clearly indicates only strings or None are accepted. The documentation also explicitly states the parameter should be "str". However, the function performs no runtime type validation, leading to unclear error messages when invalid types are passed.