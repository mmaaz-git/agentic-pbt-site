Documentation Analysis for scipy.fft.irfft
==========================================

Based on the official scipy documentation and source code review:

1. Function Purpose:
   - scipy.fft.irfft computes the inverse of the 1-D discrete Fourier Transform for real input
   - It's designed to work with output from rfft() to provide round-trip transformation
   - The documentation states: "irfft(rfft(x), len(x)) == x" within numerical accuracy

2. Parameter 'n' Documentation:
   The documentation explicitly states for the 'n' parameter:
   - "Length of the transformed axis of the output"
   - "If n is not given, it is taken to be 2*(m-1), where m is the length of the input along the axis specified by axis"
   - "The default value of n assumes an even output length"

3. Source Code Implementation:
   Looking at the actual implementation in scipy/fft/_pocketfft/basic.py (lines 87-90):
   ```python
   if n is None:
       n = (tmp.shape[axis] - 1) * 2
       if n < 1:
           raise ValueError(f"Invalid number of data points ({n}) specified")
   ```

4. Documentation vs Implementation:
   - The documentation correctly describes the formula: n = 2*(m-1)
   - The implementation follows this formula exactly
   - For m=1 (single element), this gives n = 2*(1-1) = 0
   - The code then checks if n < 1 and raises an error

5. Round-trip Behavior:
   The documentation emphasizes that irfft should provide round-trip compatibility with rfft. However:
   - rfft([1.0]) produces [1.0+0j] (single complex element)
   - irfft([1.0+0j]) without n fails with the error
   - irfft([1.0+0j], n=1) works and returns [1.0]

6. Documentation Clarity:
   The documentation does NOT explicitly state:
   - What happens for single-element inputs
   - That n must be explicitly specified for m=1 cases
   - Any special handling or restrictions for edge cases

The documentation accurately describes the formula being used but does not warn about or document the edge case where this formula produces an invalid value (n=0) for single-element inputs.