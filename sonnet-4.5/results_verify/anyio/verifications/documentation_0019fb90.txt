## Documentation Analysis for MultiListener

### Official Documentation

From the class docstring and built-in help:

```
Combines multiple listeners into one, serving connections from all of them at once.

Any MultiListeners in the given collection of listeners will have their listeners
moved into this one.

Extra attributes are provided from each listener, with each successive listener
overriding any conflicting attributes from the previous one.
```

### Key Finding: "moved into"

The documentation explicitly states that nested MultiListeners will have their listeners **"moved into"** the new MultiListener. The word "moved" is significant here.

### Interpretation Issues

1. **Ambiguity of "moved"**:
   - The documentation uses the word "moved" which could suggest a transfer operation (removing from one place and putting in another)
   - However, it's unclear whether "moved" means:
     a) The listeners are conceptually moved (flattened) into the new MultiListener
     b) The listeners are physically moved (removed from the original and placed in the new)

2. **No explicit warning about mutation**:
   - The documentation does NOT explicitly warn that the input MultiListener will be mutated
   - There is no mention that the original MultiListener becomes unusable after this operation
   - No warning like "Note: This will clear the listeners from any nested MultiListener objects"

3. **Standard Python conventions**:
   - In Python, constructors typically don't mutate their input arguments unless explicitly documented
   - Methods that mutate objects usually have clear naming (e.g., list.pop(), dict.clear()) or explicit documentation
   - The word "moved" alone is insufficient to indicate destructive mutation

4. **Sequence parameter type**:
   - The parameter is typed as `Sequence[Listener[T_Stream]]`
   - Sequences are generally expected to be read-only in constructor contexts
   - Mutating elements within a sequence parameter is unexpected behavior

### Comparison with similar patterns

Many Python libraries handle nested structures without mutation:
- itertools.chain doesn't mutate input iterables
- list.extend() doesn't mutate the source list
- dict.update() doesn't clear the source dict

### Conclusion

While the documentation uses the word "moved", it does not adequately communicate that:
1. The operation is destructive to nested MultiListener objects
2. The original MultiListener becomes unusable after being passed as input
3. This violates the principle of least surprise for Python constructors

The documentation is ambiguous at best and misleading at worst about this mutation behavior.