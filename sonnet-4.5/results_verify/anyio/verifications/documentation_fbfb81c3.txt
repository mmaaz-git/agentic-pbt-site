## Documentation Analysis

After thoroughly examining the documentation for AnyIO's CapacityLimiter, here's what I found:

### Official Documentation Review:

1. **Python help() documentation**: Shows that `CapacityLimiter(total_tokens: 'float')` accepts a float parameter

2. **Docstring for total_tokens property** (lines 513-523):
   - States "The total number of tokens available for borrowing"
   - Says it's a read-write property
   - Mentions behavior when increased (waking waiting tasks)
   - Does NOT specify whether it must be an integer or can be a float

3. **AnyIO ReadTheDocs**:
   - The synchronization documentation shows examples using integers but doesn't explicitly prohibit floats
   - No explicit statement that only integers are allowed
   - The API reference doesn't provide detailed type constraints

4. **Version History**:
   - Version 3.0 made `total_tokens` writable
   - No mention of type restrictions being added or changed

### Key Observation:
The documentation NOWHERE explicitly states that `total_tokens` must be an integer. The type hints consistently use `float` throughout:
- Constructor: `CapacityLimiter(total_tokens: float)`
- Property getter: `def total_tokens(self) -> float`
- Property setter: `def total_tokens(self, value: float) -> None`

### Documentation Gap:
There's a clear mismatch between:
1. What the type hints promise (accepts float)
2. What the implementation enforces (only int or math.inf)
3. What the documentation says (nothing explicit about this restriction)

The documentation fails to communicate the actual runtime constraint that only integers and math.inf are accepted. This is a documentation deficiency - users reading the type hints or documentation would reasonably expect any valid float to work.

### Conclusion:
The documentation and type hints create a reasonable expectation that float values like 1.5 should be accepted. The runtime rejection of these values contradicts the documented API contract.