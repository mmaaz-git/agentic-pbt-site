BUG TRIAGE ANALYSIS
===================

Evaluating against each possible category:

1. INVALID (Code is correct, report is wrong)
   Arguments AGAINST:
   - Type annotations explicitly promise float support
   - The implementation clearly violates its own type contract
   - No documentation states integers-only restriction
   Arguments FOR:
   - None found

2. WONTFIX (Trivial/unimportant issue)
   Arguments AGAINST:
   - Type safety violations are not trivial
   - This could break type-checked code that relies on annotations
   - Fractional tokens could have valid use cases (rate limiting, weighted resources)
   Arguments FOR:
   - Most practical uses might only need integer tokens
   - Has apparently worked this way without major complaints

3. FEATURE_REQUEST (Asking for unsupported functionality)
   Arguments AGAINST:
   - The type annotation already declares float support - it's not a new feature
   - This is about fixing existing incorrect behavior, not adding new capabilities
   Arguments FOR:
   - Could argue fractional tokens weren't intended originally

4. DOCUMENTATION_FIX (Documentation is wrong about behavior)
   Arguments AGAINST:
   - The code implementation is clearly more restrictive than necessary
   - Type annotations are a form of documentation and they're correct
   - Changing docs to say "int only" would make the float return type inconsistent
   Arguments FOR:
   - Could fix by changing type annotations to Union[int, float] with docs explaining restriction
   - Implementation has been this way and might be intentional

5. BUG (Valid bug that should be fixed)
   Arguments FOR:
   - Clear type contract violation between annotation and implementation
   - No documented reason for the restriction
   - The getter returns float, suggesting float values are intended
   - available_tokens also returns float, indicating fractional tokens are conceptually valid
   - The restriction seems arbitrary - accepts math.inf (a float) but not 2.5
   - Type checkers would allow code that fails at runtime
   Arguments AGAINST:
   - Could argue the implementation is correct and annotations are wrong

CONCLUSION:
----------
This is a BUG. The implementation violates its type contract without justification. The type system explicitly promises float support throughout (parameters, return types, related properties), but the runtime validation arbitrarily rejects non-integer floats. This creates a situation where type-checked code can fail at runtime, which defeats the purpose of type annotations.

The fact that math.inf (a float value) is accepted while 2.5 is rejected shows the restriction is inconsistent with the type system's promise. Either the type should be changed to indicate the restriction, or (preferably) the implementation should honor its contract.