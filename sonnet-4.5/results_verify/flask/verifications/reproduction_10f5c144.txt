REPRODUCTION ANALYSIS
====================

I successfully reproduced the bug described in the report. Here's what I found:

1. The Hypothesis test demonstrates that the `update()` method DOES accept non-uppercase keys:
   - When I ran the test with {'0': 0}, it failed with the assertion "Non-uppercase key '0' should not be in config after update()"
   - This proves that `update()` accepts all keys, including non-uppercase ones

2. The manual reproduction code confirms the behavior difference:
   - config.update({'lowercase_key': 'value1', 'UPPERCASE_KEY': 'value2'})
     Result: Both 'lowercase_key' and 'UPPERCASE_KEY' are in the config

   - config2.from_mapping({'lowercase_key': 'value1', 'UPPERCASE_KEY': 'value2'})
     Result: Only 'UPPERCASE_KEY' is in the config, 'lowercase_key' is filtered out

3. The actual source code confirms this behavior:
   - `update()` is inherited from Python's dict class and accepts all keys without filtering
   - `from_mapping()` (lines 304-321 in config.py) explicitly filters keys with `if key.isupper():`

The bug report is accurate: The docstring for `from_mapping()` states "Updates the config like :meth:`update` ignoring items with non-upper keys." This is misleading because it suggests `update()` and `from_mapping()` behave similarly, when in fact:
- `update()` accepts ALL keys (uppercase and non-uppercase)
- `from_mapping()` accepts ONLY uppercase keys

The phrasing "like :meth:`update`" incorrectly implies they have similar behavior, which could confuse users about the actual difference between these methods.