REPRODUCTION ANALYSIS
=====================

I successfully reproduced the bug reported in the issue. The bug is confirmed to exist.

Test Results:
1. Hypothesis Test: FAILED
   - The test failed with the explicit example using np.finfo(np.float64).max
   - Error: AssertionError showing that 1.7976931348623157e+308 != inf after round-trip
   - The round-trip property is violated for the maximum float64 value

2. Manual Reproduction: CONFIRMED
   - Original value: 1.7976931348623157e+308 (finite)
   - JSON representation: [{"value":1.797693135e+308}] (truncated to 10 digits precision)
   - After round-trip: inf (non-finite)
   - The value is silently converted from a valid finite float64 to infinity

3. Additional Testing:
   - The bug affects specifically the maximum float64 value (1.7976931348623157e+308)
   - Values slightly below the maximum (e.g., max_val * 0.99999) round-trip correctly
   - The default double_precision=10 truncates the value to 1.797693135e+308
   - When parsed, this truncated value rounds up slightly, exceeding float64 max
   - Using precise_float=True causes a "Range error when decoding numeric as double"
   - The maximum allowed double_precision is 15, which still causes the same issue

Bug Impact:
The bug causes silent data corruption where valid finite float64 values are converted to infinity during JSON serialization round-trips. This affects data integrity for applications working with values near the float64 limits.