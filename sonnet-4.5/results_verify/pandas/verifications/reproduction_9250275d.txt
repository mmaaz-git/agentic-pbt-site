## Reproduction Analysis

I successfully reproduced the bug described in the report. Here are my findings:

### Bug Reproduction
The specific failing input `1.401298464324817e-45` indeed gets formatted as "0%" by the `format_percentiles` function, despite:
1. Not being equal to 0.0 (confirmed: `percentile == 0.0` returns False)
2. Not being an integer when multiplied by 100 (confirmed: `(percentile * 100).is_integer()` returns False)

### Extended Testing
I tested various small values to understand the threshold at which this behavior occurs:
- Values from 0.0 to 1e-10 (inclusive) are formatted as "0%" without decimals
- 1e-8 is formatted as "1e-06%" (scientific notation)
- 1e-6 and larger are formatted with decimal places (e.g., "0.0001%", "0.01%", etc.)

### Key Observation
The function incorrectly rounds extremely small non-zero values (specifically those â‰¤ 1e-10) to "0%" without any decimal places. This appears to be a systematic issue with how the function handles very small percentiles, not just a single edge case.

The bug report's claim is accurate: the function is violating its documented contract by rounding non-zero values to exactly "0%" and not including decimal places for non-integer percentages.