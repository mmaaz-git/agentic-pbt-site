DOCUMENTATION ANALYSIS
======================

1. PANDAS DOCUMENTATION REVIEW:
The official pandas documentation for hash_array (pandas.util.hash_array) states:
- Function purpose: "Given a 1d array, return an array of deterministic integers"
- Return value: "Hashed values, same length as the vals"
- No explicit mention of floating-point handling
- No explicit mention of signed zero behavior
- No explicit documentation about the hash invariant (equal values must have equal hashes)

2. IMPLICIT EXPECTATIONS:
While not explicitly documented, there are universal expectations for hash functions:
- Hash functions must maintain the invariant: if a == b, then hash(a) == hash(b)
- This is a fundamental property of hash functions across all programming languages
- Python's own hash() function follows this rule for 0.0 and -0.0

3. PANDAS USAGE CONTEXT:
The hash_array function is used internally by pandas for:
- hash_pandas_object() which hashes Series, DataFrames, and Index objects
- groupby operations
- duplicate detection
- merge/join operations
All of these operations assume the hash invariant is maintained.

4. IEEE 754 STANDARD:
The IEEE 754 floating-point standard explicitly defines:
- Positive zero (0.0) and negative zero (-0.0) as distinct bit patterns
- These values must compare as equal (0.0 == -0.0 is True)
- Most operations treat them identically

5. NUMPY BEHAVIOR:
Numpy, which pandas builds upon, treats 0.0 and -0.0 as equal:
- np.equal(0.0, -0.0) returns True
- np.array_equal([0.0], [-0.0]) returns True

6. DOCUMENTATION GAPS:
The pandas documentation does not:
- Explicitly state that the hash function maintains the equality invariant
- Document special handling for floating-point edge cases
- Mention signed zero behavior
However, maintaining the hash invariant is such a fundamental expectation that it doesn't need explicit documentation.

CONCLUSION:
While the documentation doesn't explicitly state that equal values must have equal hashes, this is a universally expected property of hash functions. The current behavior violates this fundamental expectation and is inconsistent with Python's built-in hash() and the IEEE 754 standard's equality semantics.