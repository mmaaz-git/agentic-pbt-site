## Reproduction Results for DeepChainMap.__delitem__ Bug Report

### Test 1: Direct Reproduction of Reported Bug
The bug report's example code was executed successfully:
```
map1 = {'x': 100, 'y': 200}
map2 = {'x': 999, 'z': 300}
dcm = DeepChainMap(map1, map2)
del dcm['x']
```

**Result**: CONFIRMED - After deletion, 'x' is still accessible with value 999
- Before deletion: dcm['x'] = 100 (from map1)
- After deletion: dcm['x'] = 999 (from map2)
- The key was only deleted from map1, not map2

### Test 2: Property-Based Test with Hypothesis
The hypothesis test provided in the bug report was executed:
**Result**: FAILED with "After deletion, 0 should not be accessible"
This confirms the test correctly identifies the behavior where keys remain accessible after deletion.

### Test 3: Comparison with Standard Python ChainMap
Testing Python's standard collections.ChainMap with the same scenario:
**Result**: IDENTICAL BEHAVIOR
- Standard ChainMap also only deletes from the first map
- After deletion, the key remains accessible from subsequent maps
- This is consistent with Python's documented ChainMap behavior

### Test 4: Comparison with DeepChainMap.__setitem__
Testing how DeepChainMap handles updates for consistency:
```
dcm['x'] = 777  # where 'x' exists in both map1 and map2
```
**Result**: Updates only map1 (first occurrence), not map2
- This shows __setitem__ and __delitem__ are consistent in their "first-found" semantics

### Technical Analysis
1. The behavior is technically correct and consistent with:
   - Python's standard ChainMap behavior
   - DeepChainMap's own __setitem__ implementation
   - The general ChainMap design pattern

2. The "bug" is actually a misunderstanding of ChainMap semantics:
   - ChainMaps are designed to overlay multiple mappings
   - Operations affect only the first occurrence in the chain
   - This allows for scope-like behavior where inner scopes can shadow outer ones

3. The claimed "deletion invariant" (`del container[key] => key not in container`) is not universally true for ChainMap-like structures by design. ChainMaps intentionally violate this to support scope shadowing.

### Conclusion
The reported behavior is reproduced exactly as described, but this is the intended behavior inherited from Python's ChainMap design, not a bug.