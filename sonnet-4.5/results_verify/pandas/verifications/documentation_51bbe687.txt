## Documentation Findings for pandas.errors.AbstractMethodError

### Official Documentation
The pandas API documentation shows that AbstractMethodError is a custom exception that extends NotImplementedError. It is specifically designed for raising errors when abstract methods are not implemented in concrete classes.

### Constructor Parameters
- `class_instance`: Documented as "The class or instance where the abstract method is not implemented"
- `methodtype`: Optional parameter (defaults to "method") that can be set to "method", "classmethod", "staticmethod", or "property"

### Documentation Examples
The documentation provides examples showing:
1. For classmethods: `raise pd.errors.AbstractMethodError(cls, methodtype="classmethod")` where `cls` is the class object
2. For instance methods: `raise pd.errors.AbstractMethodError(self)` where `self` is the instance

### Key Observations
1. The documentation example for classmethod (line 282) passes `cls` (a class object) as the first parameter when methodtype="classmethod"
2. The parameter is named `class_instance`, which is ambiguous - it could mean either a class or an instance
3. The docstring says "The class or instance where the abstract method is not implemented", suggesting both classes and instances are valid inputs
4. There is NO explicit requirement in the documentation that states `class_instance` must be a class when `methodtype="classmethod"`

### Implementation Details from Source Code
- Line 294-301: The `__init__` method accepts any object as `class_instance` and only validates that `methodtype` is one of the allowed values
- Line 303-308: The `__str__` method has different behavior:
  - When methodtype="classmethod": accesses `self.class_instance.__name__` directly (line 305)
  - For other methodtypes: uses `type(self.class_instance).__name__` (line 307)

### Documentation Ambiguity
The documentation is ambiguous because:
1. The parameter name `class_instance` doesn't clearly indicate whether it expects a class or instance
2. The docstring says "class or instance", implying both are valid
3. The examples only show the conventional usage (cls for classmethods) but don't explicitly forbid instances
4. There's no validation in __init__ that enforces type constraints based on methodtype

This ambiguity in documentation and naming convention creates confusion about the expected behavior when an instance is passed with methodtype="classmethod".