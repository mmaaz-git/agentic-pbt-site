## Bug Reproduction Report

I have successfully reproduced the bug described in the report. Both the Hypothesis test and manual reproduction confirm the issue.

### Hypothesis Test Result
The property-based test with Hypothesis failed exactly as described in the bug report:
- Failing input: `window_size=-1, num_values=2`
- Error: `AssertionError: Window bounds invariant violated: start must be <= end for all indices`

### Manual Reproduction
Running the manual test case with `window_size=-1` and `num_values=2`:
- start array: [0, 1]
- end array: [0, 0]
- At index 1: start[1]=1 > end[1]=0, violating the invariant

### Extended Testing
Testing with more values (`window_size=-1, num_values=5`) shows a consistent pattern:
- start: [0, 1, 2, 3, 4]
- end: [0, 0, 1, 2, 3]
- Violations at indices 1-4 where start[i] > end[i]

### Code Analysis
The issue occurs in the `get_window_bounds` method (lines 340-343):
1. `start = np.arange(0, num_values, step)` creates [0, 1, 2, ...]
2. `end = start + self.window_size` with negative window_size gives negative values
3. `np.clip(end, 0, num_values)` clips negative values to 0
4. This results in end values being less than start values for indices > 0

### Comparison with Standard Rolling
The standard pandas `rolling(window=n)` function properly validates window size:
- Attempting `df.rolling(window=-1)` raises: `ValueError: window must be an integer 0 or greater`
- FixedForwardWindowIndexer does not perform this validation

The bug is real and reproducible. The FixedForwardWindowIndexer accepts negative window sizes and produces invalid window bounds where end < start, violating the fundamental window bounds invariant that should always hold: start[i] <= end[i] for all i.