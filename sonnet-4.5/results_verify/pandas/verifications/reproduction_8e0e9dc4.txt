REPRODUCTION ANALYSIS
=====================

I have successfully reproduced the bug described in the report. The issue is confirmed and occurs exactly as described.

## Bug Reproduction

1. **Hypothesis Test**: The provided property-based test fails on the specific example:
   - Input: datetime(2000, 1, 2), format '%Y-%m-%d', dayfirst=True
   - The test correctly identifies that the round-trip fails
   - The guessed format '%Y-%d-%m' causes "2000-01-02" to be parsed as February 1st, 2000 instead of January 2nd, 2000

2. **Simple Reproduction**: The simple test case also confirms the bug:
   - Input string: "2000-01-02"
   - With dayfirst=True, the function returns '%Y-%d-%m'
   - This causes datetime.strptime to parse it as 2000-02-01 (February 1st)
   - The expected result should be 2000-01-02 (January 2nd)

3. **Extended Testing**: I tested multiple date formats to understand the pattern:
   - "2000-01-02" with dayfirst=False returns '%Y-%m-%d' (correct, parses to 2000-01-02)
   - "2000-01-02" with dayfirst=True returns '%Y-%d-%m' (incorrect, parses to 2000-02-01)
   - "2000/01/02" shows the same behavior (correct without dayfirst, incorrect with it)

## Key Finding

The function applies the dayfirst logic indiscriminately to ALL date formats, including ISO-format dates (YYYY-MM-DD or YYYY/MM/DD) where the year comes first. This is illogical because when a 4-digit year appears first, there is no ambiguity about whether the day or month comes first - the standard convention is always month-then-day after the year.

The bug is real and causes incorrect date parsing when dayfirst=True is used with year-first date formats.