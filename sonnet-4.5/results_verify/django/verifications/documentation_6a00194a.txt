DOCUMENTATION ANALYSIS
======================

1. SIGNAL CLASS DOCUMENTATION
The official Django documentation (https://docs.djangoproject.com/en/5.1/topics/signals/) does NOT document the use_caching parameter at all. The Signal class constructor parameters are not described in the public API documentation.

2. SOURCE CODE DOCUMENTATION
Looking at the source code in dispatcher.py:
- Line 35: __init__(self, use_caching=False) - The parameter exists but has no documentation
- Lines 43-46: Comments explain caching is used for performance optimization
- Line 47: Shows WeakKeyDictionary is used when caching is enabled

3. SENDER PARAMETER DOCUMENTATION
From the connect() method docstring (lines 69-71):
"sender: The sender to which the receiver should respond. Must either be a Python object, or None to receive events from any sender."

This explicitly states that:
- sender can be "a Python object" (any Python object)
- sender can be None (to receive from any sender)

4. NO DOCUMENTED RESTRICTIONS
There is NO documentation that:
- Warns about restrictions when use_caching=True
- States that certain sender types cannot be used with caching
- Mentions that senders must support weak references when caching is enabled
- Explains the WeakKeyDictionary limitation

5. WEAK REFERENCE DOCUMENTATION
The documentation discusses weak references for RECEIVERS (not senders):
- Line 61: "If weak is True, then receiver must be weak referenceable"
- This is about receivers, not senders
- There's no equivalent warning for senders

6. API CONTRACT
The documented API contract is:
- Signal can be created with use_caching (though undocumented in public docs)
- sender can be "any Python object or None"
- No restrictions are mentioned

7. CONCLUSION
The documentation does not warn users about this limitation. The API accepts parameters that will cause a crash. This is not a case of undefined behavior - the documentation explicitly says sender can be "a Python object, or None", both of which fail when caching is enabled.