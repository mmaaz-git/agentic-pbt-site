## Documentation Analysis

### Official Django Documentation:
The official Django documentation for template variables does not explicitly document:
1. How numeric literals with trailing dots should be handled
2. Whether strings like "2." are valid or invalid inputs
3. The invariant that a Variable should have either `literal` OR `lookups` set, but not both

The documentation only provides general guidance about variable syntax and lookup behavior.

### Source Code Documentation:
1. **Class Docstring**: The Variable class docstring (lines 784-800) only shows examples of variable lookups and string literals. It doesn't mention numeric literals at all.

2. **Code Comment**: Line 824 explicitly states `# "2." is invalid`, indicating the developer's intent that strings ending with a dot should be rejected as invalid numeric literals.

3. **Implementation Intent**: The code structure in `__init__` shows clear intent:
   - Lines 806-807: Initialize both `literal` and `lookups` to None
   - Lines 814-828: Try to parse as a numeric literal
   - Lines 829-848: If that fails, try other literal formats or set as lookup
   - The structure implies mutual exclusivity - either it's a literal OR a lookup

### Key Finding:
The comment "# '2.' is invalid" at line 824 is the only documentation of the expected behavior for trailing dots. This comment, combined with the `raise ValueError` on line 826, clearly indicates that strings like "2." should be rejected entirely - not parsed as float(2.0) nor as a lookup.

### Documented Invariant:
While not explicitly stated in documentation, the code structure and the resolve() method's implementation (lines 852-857) clearly establish an invariant:
- If `self.lookups is not None`: perform variable resolution
- Else: use `self.literal` value

This if-else structure proves the intended mutual exclusivity - a Variable should be either a literal or a lookup, never both.

### Conclusion:
The lack of explicit documentation about numeric literal formats doesn't make this behavior undefined. The code comment explicitly states "2." is invalid, and the attempt to raise ValueError shows clear intent to reject such input. The current behavior (setting both literal and lookups) violates the designed invariant and contradicts the documented intent in the code comment.