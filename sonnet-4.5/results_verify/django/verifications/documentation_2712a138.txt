Documentation Analysis for django.template.Variable
=====================================================

After examining the Django source code and attempting to find official documentation, here's what I found:

1. Django Template Variable Class:
   - The Variable class is an internal implementation detail in django/template/base.py
   - There is no public API documentation specifically for the Variable class itself
   - The Django template documentation describes variable syntax in templates (e.g., {{ variable_name }}) but does not document the Variable class constructor or its expected behavior with numeric literals

2. Comments in the Source Code:
   - Line 824 in django/template/base.py contains the comment: # "2." is invalid
   - This comment explicitly indicates that numeric literals ending with a period are considered invalid
   - The code attempts to enforce this by raising ValueError on line 826 when var[-1] == "."

3. Intended Behavior from Code:
   - Variables should be either literals OR lookups, never both
   - The resolve() method (lines 850-866) checks if self.lookups is not None first, and only uses self.literal if lookups is None
   - This design indicates mutual exclusivity between literal and lookups attributes

4. Numeric Literal Handling:
   - The code tries to parse numeric literals first (lines 814-828)
   - If successful, it should be a literal value
   - If parsing fails (ValueError), it then tries to interpret it as a string literal or variable lookup

5. Documentation Gaps:
   - There is no explicit documentation about:
     * Whether numeric literals with trailing periods should be accepted
     * The mutual exclusivity of literal vs lookups attributes
     * The internal Variable class API contract
   - The template language documentation focuses on user-facing syntax, not internal implementation

6. Code Intent vs Implementation:
   - The comment "# '2.' is invalid" and the ValueError raise on line 826 clearly show the intent to reject trailing periods
   - However, the implementation has a bug where self.literal gets set before the ValueError is raised
   - When the ValueError is caught, self.literal remains set, and execution continues to also set self.lookups

Conclusion:
The code clearly intends to reject numeric literals with trailing periods based on the explicit comment and ValueError logic. The current behavior where both literal and lookups get set is unintended and violates the implicit contract that these should be mutually exclusive.