## Documentation Analysis

### Key Documentation Findings

1. **Operation Base Class Documentation** (base.py, lines 27-28):
   - Explicitly states: "Due to the way this class deals with deconstruction, it should be considered immutable."
   - This is a clear contract that all Operation subclasses should follow

2. **Reduce Method Documentation** (base.py, lines 150-154):
   - States: "Return either a list of operations the actual operation should be replaced with or a boolean that indicates whether or not the specified operation can be optimized across."
   - The method should RETURN new operations, not mutate existing ones

3. **MigrationOptimizer Documentation** (optimizer.py):
   - The optimizer runs multiple optimization iterations (lines 33-38)
   - It calls `operation.reduce(other, app_label)` repeatedly (line 47)
   - Operations may be reused across multiple optimization passes
   - The optimization "must be stable and always return an equal or shorter list" (line 27)

4. **Django Documentation**:
   - The official docs mention: "For performance reasons, the Field instances in ModelState.fields are reused across migrations. You must never change the attributes on these instances."
   - While this specifically refers to Field instances, it establishes a pattern of immutability for migration-related objects

5. **Index Class**:
   - Has a `clone()` method (indexes.py, line 153) that creates a copy
   - This provides the proper way to create modified versions without mutation

### Implications

The documentation strongly supports that:
1. Migration operations should be immutable
2. The reduce() method should return new operations, not mutate existing ones
3. Operations can be reused multiple times by the optimizer
4. Mutation would violate the stability requirement of the optimization process

The bug report correctly identifies that `AddIndex.reduce()` violates the documented immutability contract by directly mutating `self.index.name` instead of creating a new operation with a cloned index.