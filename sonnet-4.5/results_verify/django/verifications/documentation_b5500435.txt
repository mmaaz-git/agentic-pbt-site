## Documentation Analysis

### Source Code Documentation
From the Django source code (dispatcher.py), the `connect()` method's docstring explicitly states:

**Line 69-71:**
"sender: The sender to which the receiver should respond. Must either be a Python object, or None to receive events from any sender."

This is clear documentation that `sender=None` is a valid and expected use case.

### Signal Constructor Documentation
The Signal class constructor (line 35-38) accepts `use_caching` parameter:
- The parameter is documented in comments (lines 43-46) explaining it creates caches for distinct senders
- The cache uses `weakref.WeakKeyDictionary()` when caching is enabled (line 47)
- No documentation warns about limitations with certain sender types

### API Contract Violations
The documentation explicitly supports:
1. **sender=None**: Documented as valid for receiving events from any sender
2. **"Python object"**: The phrase "Python object" is inclusive and doesn't restrict to weak-referenceable objects only

### Missing Documentation
The documentation fails to mention:
1. That `use_caching=True` has restrictions on sender types
2. That certain common Python types (None, str, int, etc.) cannot be used as senders when caching is enabled
3. That the caching optimization changes the API surface and breaks documented functionality

### Django Ticket History
From search results, Django tickets #20943 and #16679 discuss signal receiver caching optimizations, but there's no mention that the optimization should break support for certain sender types.

### Conclusion
The documentation clearly states that `sender=None` and any Python object should work. The `use_caching` parameter is presented as a transparent optimization without documented restrictions. The current implementation violates the documented API contract.