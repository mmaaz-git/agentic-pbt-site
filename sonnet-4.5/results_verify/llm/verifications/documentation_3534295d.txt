# Documentation Analysis

## Function Documentation Review

The `monotonic_ulid()` function has clear documentation in its docstring (lines 690-701):

### Stated Guarantees

1. **Primary Guarantee**: "Return a ULID instance that is guaranteed to be *strictly larger* than every other ULID returned by this function inside the same process."

2. **Implementation Details**: Claims to work "the same way the reference JavaScript `monotonicFactory` does"

3. **Specified Behaviors**:
   - Same millisecond: Increment the 80-bit randomness part by exactly one
   - Clock moves forward: Generate brand-new ULID with secure randomness
   - Overflow protection: Raises `OverflowError` if >2^80 ULIDs in same millisecond

### Notable Omission

The documentation does NOT explicitly specify what should happen when the clock moves backward. It only mentions:
- "If the current call happens in the same millisecond" (line 695)
- "As soon as the system clock moves forward" (line 697)

There is no mention of backward clock movement.

## Reference Implementation Research

### JavaScript monotonicFactory

Based on my research of the reference JavaScript implementation:

1. The JavaScript `monotonicFactory` documentation states: "Even if a lower timestamp is passed (or generated), it will preserve sort order"

2. This indicates the reference implementation DOES handle backward clock movement by maintaining monotonicity

3. The JavaScript implementation appears to treat backward clock movement similarly to same-millisecond scenarios

## Documentation Gap

The Python implementation's documentation claims to work "the same way the reference JavaScript `monotonicFactory` does", but:

1. The JavaScript reference handles backward clocks to maintain monotonicity
2. The Python documentation doesn't mention this behavior
3. The Python implementation doesn't handle backward clocks correctly

## Conclusion

The documentation is incomplete but the claim that it works "the same way the reference JavaScript `monotonicFactory` does" creates an implicit requirement that backward clock movement should be handled. The actual implementation violates both:
- The explicit guarantee of strict monotonicity
- The implicit requirement to match the reference implementation's behavior

This is a legitimate bug, not a documentation issue, because:
1. The primary guarantee of strict monotonicity is explicitly stated and violated
2. The claim of matching the reference implementation's behavior is false
3. Clock backward movement is a real-world scenario that monotonic functions should handle