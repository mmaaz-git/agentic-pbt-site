Bug Triage Analysis
===================

Evaluating this bug report against each possible triage category:

1. INVALID
   Why it might be INVALID:
   - Python's duck typing philosophy often treats 0.0 and 0, 1.0 and 1 as equivalent
   - The function could be considered "working as intended" with Python's semantics

   Why it's NOT INVALID:
   - The documentation explicitly lists integer values 0 and 1, not floats
   - The documentation provides an exhaustive list of accepted values
   - Other float values (0.5, 1.5, 2.0) correctly raise ValueError
   - The documentation contract is clear and unambiguous

2. WONTFIX
   Why it might be WONTFIX:
   - The current behavior might be considered a minor issue
   - Some might argue that 0.0 == 0 and 1.0 == 1 in Python makes this acceptable
   - It only affects two specific float values

   Why it's NOT WONTFIX:
   - This is not an obscure edge case - 0.0 and 1.0 are common float values
   - The behavior violates the documented API contract
   - It creates inconsistent behavior (0.0 accepted but 2.0 rejected)
   - This could cause real bugs in code expecting strict type validation

3. FEATURE_REQUEST
   Why it might be FEATURE_REQUEST:
   - Could be seen as requesting stricter type checking

   Why it's NOT FEATURE_REQUEST:
   - The bug report is not asking for new functionality
   - It's asking for the function to behave according to its existing documentation
   - The documentation already defines the expected behavior

4. DOCUMENTATION_FIX
   Why it might be DOCUMENTATION_FIX:
   - The documentation could be updated to say "0, 1 and their float equivalents"
   - Could add a note about Python's numeric equality semantics

   Why it's NOT just DOCUMENTATION_FIX:
   - The documentation is already clear and specific
   - The behavior is inconsistent (only 0.0 and 1.0 work, not other floats)
   - Users rely on documentation contracts for type safety
   - Changing documentation would weaken the API contract

5. BUG
   Why it IS a BUG:
   - The implementation violates the documented API contract
   - The documentation explicitly lists integer values 0 and 1
   - The behavior is inconsistent - accepts 0.0/1.0 but rejects 2.0
   - This is a type safety issue that could cause unexpected behavior
   - The fix is straightforward and improves API consistency
   - Users expecting strict validation based on docs will encounter unexpected behavior

Final Assessment:
This is a valid BUG. The implementation accepts values that are not documented as valid inputs,
violating the API contract. While Python's duck typing makes 0.0 == 0, the documentation
explicitly lists the accepted values, and float values are notably absent from that list.
The inconsistent behavior (accepting 0.0/1.0 but not 2.0) further confirms this is a bug
rather than intentional design.