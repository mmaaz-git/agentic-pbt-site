## Documentation Analysis for Cython.Tempita Default Directive

### Official Documentation Found

1. **In-code documentation (Cython/Tempita/_tempita.py, lines 1-30):**
   - Line 17 shows the syntax: `{{default var = default_value}}`
   - This is the only documentation about the default directive in the module itself
   - No mention of error handling for malformed directives

2. **Error messages in parse_default function:**
   - Line 885: "Expression must be {{default var=value}}; no = found in %r"
   - Line 890: "{{default x, y = ...}} is not supported"
   - Line 894: "Not a valid variable name for {{default}}: %r"
   - These error messages document the expected format

### What the Documentation Says

The documentation indicates that:
- The correct syntax is `{{default var = default_value}}`
- A variable name and value are required, separated by `=`
- Multiple variable assignment (like `x, y = ...`) is not supported
- Variable names must match the pattern `[a-z_][a-z0-9_]*` (case insensitive)

### What the Documentation Does NOT Say

The documentation does not specify:
- What happens when `{{default}}` or `{{default }}` is written without any variable
- Whether such malformed syntax should be treated as a directive or an expression
- What type of error should be raised for incomplete default directives

### Parser Behavior vs Documentation

The actual parser behavior is:
1. Only tokens that match `startswith('default ')` (after stripping) are treated as default directives
2. `{{default}}` or `{{default }}` are NOT recognized as default directives because after stripping they become just `'default'`
3. These are instead treated as regular Python expressions
4. This behavior is not explicitly documented but follows from the parser's design

### External Documentation

- Searched for Tempita documentation on PyPI and GitHub
- The original Tempita project documentation doesn't provide more detail about error handling
- Cython's version is a fork/vendored copy with similar behavior

### Conclusion on Documentation

The documentation does not explicitly state that `{{default}}` without a variable should raise a TemplateError. The current behavior (treating it as a Python expression) is reasonable given that:
1. It doesn't match the directive pattern after stripping
2. The fallback to expression evaluation is the default for unrecognized patterns
3. The documentation only shows the correct syntax, not error cases