# Documentation Analysis

## Tempita Documentation Review

### In-Code Documentation
The Tempita module's docstring (lines 1-30 of _tempita.py) shows the syntax as:
```
{{if x}}x{{elif y}}y{{else}}z{{endif}}
```
This example shows standard if/elif/else structure with one of each clause.

### External Documentation
1. **PyPI page**: No specific syntax rules mentioned
2. **GitHub docs (ravenac95/tempita)**: Shows basic if/elif/else syntax but does not specify restrictions on:
   - Multiple else clauses
   - elif after else placement

### Documentation Gaps
The documentation does NOT explicitly state:
- Whether duplicate else clauses are allowed or prohibited
- Whether elif can appear after else
- What happens when invalid conditional structures are provided

## Python Language Comparison

Python itself strictly enforces:
1. Only one else clause per if block - `SyntaxError` for duplicates
2. No elif after else - `SyntaxError` when elif follows else

Testing confirms Python rejects both cases at compile time:
- "invalid syntax" for duplicate else
- "invalid syntax" for elif after else

## Source Code Evidence

### Comment in _tempita.py line 291
```python
# @@: if/else/else gets through
```
This comment explicitly acknowledges that duplicate else clauses "get through" the parser, indicating:
1. The author knew about this issue
2. It was left as a known bug/limitation (marked with @@: which often indicates TODO/FIXME)

### Parser Implementation
The `parse_cond` function collects all conditional parts without validation. No checks for:
- Duplicate else clauses
- elif appearing after else
- Any structural validation beyond matching endif

## Conclusion

While the documentation doesn't explicitly prohibit duplicate else or elif-after-else, these constructs violate:
1. **Implicit expectations**: The syntax example shows standard if/elif/else
2. **Python semantics**: Tempita claims to implement Python-like conditionals
3. **Common programming language rules**: No major language allows these constructs

The author's comment confirms this is a known issue where invalid syntax "gets through" when it shouldn't. The documentation's silence on this doesn't make it valid - it's an undocumented bug.