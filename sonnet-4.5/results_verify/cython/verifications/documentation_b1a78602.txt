## Documentation Analysis for RawCodeRange

### Class Documentation
The RawCodeRange class has the following documentation (lines 197-201):
```
RawCodeRange(code1, code2) is a low-level RE which matches any character
with a code |c| in the range |code1| <= |c| < |code2|, where the range
does not include newline. For internal use only.
```

Key points:
1. The class is marked as "For internal use only"
2. The documentation describes its purpose but does not specify implementation details
3. No documentation exists for the `calc_str()` method

### Architecture and Design Pattern
1. RawCodeRange inherits from the RE base class (line 196)
2. The RE base class defines `__str__()` method (lines 145-149) which:
   - Returns `self.str` if it exists
   - Otherwise calls `self.calc_str()`
3. Each RE subclass is expected to implement its own `calc_str()` method to provide string representation

### Attribute Documentation
The class defines these attributes (lines 204-206):
- `range = None            # (code, code)`
- `uppercase_range = None  # (code, code) or None`
- `lowercase_range = None  # (code, code) or None`

The comment clearly indicates that `range` should contain a tuple `(code, code)`.

### Expected Behavior
Based on the architecture:
1. When `str(RawCodeRange(x, y))` is called, it triggers `__str__()` from the base class
2. Since `self.str` is not set, it calls `calc_str()`
3. The `calc_str()` method should return a string representation

### Documentation Gap
The documentation does not explicitly state:
- How the string representation should be formatted
- That `calc_str()` must be implemented correctly
- The internal attribute structure (using `self.range` vs `self.code1/code2`)

However, this is an internal implementation detail of an internal-use-only class. The bug is in the implementation not matching the actual attribute structure used by the class.

### Conclusion
While the class is marked "for internal use only," it still needs to function correctly within the Cython.Plex module. The `calc_str()` method implementation contradicts the actual attribute structure defined and used by the class. The documentation clearly shows that `range` contains `(code, code)` tuple, not separate `code1` and `code2` attributes.