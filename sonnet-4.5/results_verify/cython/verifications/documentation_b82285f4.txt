## Documentation Analysis

### Official Documentation
The docstring at line 1032-1033 clearly states:
```
Use py:arg=value to set a Python value; otherwise all values are strings.
```

This indicates that when using the `py:` prefix, the intention is to:
1. Mark the argument as containing a Python expression
2. Evaluate that expression using `eval()`
3. Store the result under the variable name (without the prefix)

### Template Syntax Documentation
The module's main docstring (lines 1-30) shows the template syntax includes:
```
{{py:x=1}}
```

This demonstrates that in templates, `py:x=1` sets a variable named `x` to the value 1.

### Consistency Across the Module
1. **Template parsing (line 753)**: Correctly strips the `py:` prefix using `expr[3:]`
2. **Command-line parsing (line 1073)**: Incorrectly keeps the prefix using `name[:3]`

### Usage Example Analysis
The command-line usage pattern (line 1030) shows:
```
%prog [OPTIONS] TEMPLATE arg=value
```

Combined with the documentation that says "Use py:arg=value to set a Python value", it's clear that:
- `py:x=42` should create a variable named `x` with value 42
- `py:my_var=123` should create a variable named `my_var` with value 123

### Documentation Conclusion
The documentation unambiguously indicates that the `py:` prefix is a marker for Python evaluation, not part of the variable name. The current implementation violates the documented behavior by keeping "py:" as the variable name instead of stripping it to get the actual variable name.