DOCUMENTATION ANALYSIS
======================

## Available Documentation

1. **Inline Docstrings** (lines 119-124 and 130-135 in _looper.py):
   - first_group: "Returns true if this item is the start of a new group, where groups mean that some attribute has changed. The getter can be None (the item itself changes), an attribute name like '.attr', a function, or a dict key or list index."
   - last_group: "Returns true if this item is the end of a new group, where groups mean that some attribute has changed. The getter can be None (the item itself changes), an attribute name like '.attr', a function, or a dict key or list index."

2. **External Tempita Documentation** (from GitHub):
   - States that first_group and last_group "always return true when `.first` or `.last` returns true"
   - Describes various getter formats supported
   - No mention of None handling or boundary conditions with getters

## Key Findings

1. **No Documented None Handling**: The documentation does not specify what should happen when comparing with None values at boundaries. It doesn't say the methods should handle None gracefully, nor does it say they shouldn't.

2. **Implicit Contract**: The documentation states these methods "always return true" at boundaries (first/last items). This implies they should work correctly regardless of the getter used, suggesting robust handling is expected.

3. **Getter Types Documented**: The documentation clearly lists the supported getter types:
   - None (compare items directly)
   - '.attr' (attribute access)
   - '.method()' (method call)
   - 'key' (dictionary/list index)
   - callable (custom function)

4. **Missing Edge Case Documentation**: The documentation doesn't address:
   - What happens when previous/next items are None
   - Whether _compare_group is an internal or public method
   - Error handling expectations

## Documentation Interpretation

The documentation suggests that first_group and last_group should work reliably with all documented getter types. The phrase "always returns true when .first or .last returns true" implies these methods should never fail at boundaries, which supports fixing the underlying _compare_group method to handle None values properly.

The lack of explicit None handling documentation doesn't make this behavior undefined - the documented contract that these methods work with various getter types at all positions (including boundaries) implies they should handle the None case gracefully.