REPRODUCTION OF BUG REPORT FOR Cython.Utils.build_hex_version

=== Summary ===
I have successfully reproduced both bugs described in the report. The function build_hex_version()
produces incorrect output when version components exceed their expected byte boundaries.

=== Reproduction Steps ===

1. Property-Based Tests:
   - Ran the provided Hypothesis tests
   - Both test suites failed as described
   - test_large_version_numbers failed with explicit examples (256, 1000)
   - test_prerelease_versions failed with input '0.0a96'

2. Specific Bug Reproductions:

Bug 1 - Large Version Numbers:
   Input '256':
   - Expected: Value should fit in 32-bit (≤ 0xFFFFFFFF)
   - Actual: 0x1000000F0 (4294967536) - EXCEEDS 32-bit limit
   - Effect: The value 256 (0x100) requires 9 bits, overflowing the 8-bit major version field

   Input '1000':
   - Expected: Value should fit in 32-bit (≤ 0xFFFFFFFF)
   - Actual: 0x3E80000F0 (16777216240) - EXCEEDS 32-bit limit
   - Effect: The value 1000 (0x3E8) requires 10 bits, severely overflowing

Bug 2 - Prerelease Serial Overflow:
   Input '0.0a96':
   - Expected: Micro version should be 0
   - Actual: Micro version is 1
   - Cause: 96 + 0xA0 (160) = 256 = 0x100, overflows into micro byte

   Input '0.0a160':
   - Expected: Micro version should be 0
   - Actual: Micro version is 1
   - Cause: 160 + 0xA0 (160) = 320 = 0x140, overflows into micro byte

=== Impact ===
The function is used to generate CYTHON_HEX_VERSION macro in compiled Cython modules.
This macro is meant to follow Python's PY_VERSION_HEX format for version comparisons.
The overflows produce:
1. Invalid 32-bit values that cannot be properly compared
2. Corrupted version information where components spill into adjacent fields
3. Silent failures with no error messages or validation

=== Verification ===
The bugs are deterministic and consistently reproducible. The function lacks any input
validation or overflow checking, allowing invalid values to be silently produced.