## INVALID Considerations
**Why it might be INVALID:**
The documentation never explicitly promises that substitute() won't mutate the input dictionary. The behavior is technically deterministic and consistent - it always adds the same keys in the same way. One could argue that if immutability was required, the documentation would have stated it explicitly.

**Why it might not be INVALID:**
The method is explicitly compared to string.Template in the documentation, which does NOT mutate input dictionaries. The examples show passing locals() directly, which strongly suggests safe handling. The name "substitute" implies a read-only operation, and mutating input parameters violates common Python conventions and the principle of least surprise.

## WONTFIX Considerations
**Why it might be WONTFIX:**
This behavior has likely existed for years in Tempita without causing major issues. The added keys (__template_name__ and namespace values) are unlikely to conflict with user data in practice. Changing this behavior now could break existing code that inadvertently relies on the mutation. The impact is relatively minor - users can easily work around it by passing dict.copy().

**Why it might not be WONTFIX:**
This is a clear violation of expected behavior for a substitution method. The bug can cause real issues in production code where dictionaries are reused after template rendering. The fix is straightforward and wouldn't break properly written code. The mutation is an implementation detail leak that should not be exposed to users.

## DOCUMENTATION_FIX Considerations
**Why it might be DOCUMENTATION_FIX:**
The current behavior is technically functional, just unexpected. Adding a warning to the documentation about dictionary mutation would inform users of this behavior. The code works as designed, it's just the documentation that doesn't warn about the side effect. This would be the least disruptive solution.

**Why it might not be DOCUMENTATION_FIX:**
The behavior is clearly a bug, not a documentation issue. The comparison to string.Template in the docs creates a reasonable expectation of immutability. Documenting a bug doesn't make it correct behavior. The proper fix is to change the code, not document the unexpected mutation.

## FEATURE_REQUEST Considerations
**Why it might be FEATURE_REQUEST:**
One could argue that non-mutating behavior is a new feature that Tempita never promised. Adding an option for immutable substitution could be seen as an enhancement. The current behavior might be considered the "default" with immutability as an additional capability.

**Why it might not be FEATURE_REQUEST:**
This is fixing broken behavior, not adding new functionality. Immutability for read-only operations is expected behavior in Python, not a feature. The method already should work this way based on its name and documentation references. This is a bug fix, not a feature addition.

## BUG Considerations
**Why it might be BUG:**
The substitute() method mutates its input dictionary, which violates the principle of least surprise and differs from string.Template.substitute() which it's compared to in the documentation. The method name "substitute" implies a read-only operation. The documentation examples show passing locals() directly, suggesting the method should handle dictionaries safely. This is unexpected behavior that can cause real bugs in production code where dictionaries are reused. The fix is simple and correct: copy the dictionary before modifying it.

**Why it might not be BUG:**
The documentation never explicitly promises immutability. The behavior is consistent and deterministic. The module has worked this way for years without this being raised as a critical issue. Some might argue this is just how Tempita works, and changing it now could break existing code.

## Overall consideration

After careful analysis, this appears to be a legitimate bug. The substitute() method mutates its input dictionary by adding internal keys like `__template_name__` and namespace values. This behavior is clearly demonstrated and reproducible.

The key evidence supporting this being a bug includes: (1) The documentation explicitly compares Tempita's substitute() to string.Template, which does not mutate input dictionaries; (2) The method name "substitute" strongly implies a read-only operation; (3) The documentation shows examples of passing locals() directly, which would be unsafe if mutation was expected; (4) The mutation adds internal implementation details (__template_name__) that leak into user data; (5) This violates the principle of least surprise and standard Python conventions for methods that appear to be read-only.

While the documentation doesn't explicitly promise immutability, the overall context strongly suggests that mutation is unintended behavior. The fix is straightforward - copying the dictionary before modification - and would align the behavior with user expectations and similar APIs. This is a valid bug that should be fixed rather than documented or dismissed.