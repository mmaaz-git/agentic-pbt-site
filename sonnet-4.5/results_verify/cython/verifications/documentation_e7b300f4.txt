DOCUMENTATION ANALYSIS REPORT
==============================

## Available Documentation

### Module Docstring (_tempita.py lines 1-30)
The module docstring describes the templating language syntax and basic usage but makes NO mention of bytes vs string support. It only describes:
- Template syntax (expressions, filters, control structures)
- Usage with Template class and sub() function
- substitute() method accepting keyword arguments or dictionary
- TemplateError for syntax errors

### Class-Level Documentation
The Template class has NO docstring. There is no documentation at the class level describing supported input types or encoding behavior.

### Method Documentation
Individual methods lack comprehensive docstrings. The `__init__` method has no documentation about the `content` parameter's expected type.

### External Documentation
1. **PyPI Page**: Describes Tempita as "a small templating language for text substitution" with no mention of bytes support
2. **GitHub Repository**: Contains only the source files with no separate documentation files
3. **Cython Documentation**: General Cython docs discuss unicode/bytes handling but don't specifically document Tempita's capabilities

## Implicit Documentation Through Code

### Evidence of Bytes Support Intent:
1. **Line 125**: `self._unicode = isinstance(content, str)` - The existence of this flag strongly implies that non-unicode (bytes) content was intended to be supported
2. **Line 155**: `from_filename()` reads files in binary mode ('rb'), suggesting bytes content is expected
3. **Lines 336-346**: Extensive branching logic based on `self._unicode` flag
4. **Line 96**: `default_encoding = 'utf8'` - Implies encoding/decoding support
5. **Lines 351-359**: Explicit unicode/bytes conversion code with encoding support

### No Documentation Disclaimers:
- No comments or docstrings indicate that bytes are NOT supported
- No warnings about bytes limitations
- No assertion or validation rejecting bytes input

## Documentation Gap
The documentation is **silent** on the question of bytes support. However, the code architecture clearly shows that bytes support was intended:
- The `_unicode` flag's existence only makes sense if both types are supported
- The encoding/decoding infrastructure would be unnecessary if only strings were supported
- The from_filename() method reading in binary mode suggests bytes handling

## Conclusion
The documentation neither explicitly promises nor denies bytes support. However, the code structure and implementation details strongly suggest that bytes support was an intended feature that was incompletely implemented. The bug represents a failure to deliver on the implicit contract established by the code's architecture rather than a violation of documented behavior.

This is NOT a documentation issue - the code clearly attempts to support bytes but fails due to an implementation bug in the lexer.