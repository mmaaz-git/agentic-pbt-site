## Bug Reproduction Results

### Summary
The bug report is **INCORRECT**. The `not_in` constraint works correctly and properly rejects values that are in the exclusion list.

### Bug Report Claims vs Reality

1. **Bug claim**: "`operator.__not__` is the bitwise NOT operator (~)"
   **Reality**: This is FALSE. `operator.__not__` implements logical NOT, not bitwise NOT.
   - `operator.__not__(True)` returns `False` (not -2)
   - `operator.__not__(False)` returns `True` (not -1)
   - The bitwise NOT operator `~` is completely different

2. **Bug claim**: "not_in never actually rejects any values"
   **Reality**: This is FALSE. The constraint correctly rejects values.
   - Testing `Model(field=2)` with `not_in([1, 2, 3])` raises ValidationError
   - All test cases confirm proper rejection of excluded values

### Test Results

1. **Basic reproduction test**:
   - Creating a model with `field: Annotated[int, transform(lambda x: x).not_in([1, 2, 3])]`
   - Attempting to set field=2 correctly raises ValidationError
   - Error message: "Expected not in [1, 2, 3]"

2. **Property-based testing**:
   - Ran 50 hypothesis test examples
   - All tests passed correctly
   - Values in exclusion list were properly rejected
   - Values not in exclusion list were properly accepted

3. **Direct operator testing**:
   - Confirmed `operator.__not__(operator.__contains__(values, v))` produces correct boolean results
   - For value in list: returns False (reject)
   - For value not in list: returns True (accept)

### Conclusion
The implementation in pydantic.experimental.pipeline is correct. The bug report is based on a fundamental misunderstanding of what `operator.__not__` does. It is NOT the bitwise NOT operator, it IS the logical NOT operator, and the constraint functions exactly as intended.