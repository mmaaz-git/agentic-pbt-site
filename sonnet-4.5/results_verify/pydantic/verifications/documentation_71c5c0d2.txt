## Documentation Analysis

### Pydantic v1 Documentation
1. **Bytes Field Type Documentation**:
   - The documentation states that bytes are accepted "as-is" during validation
   - It documents conversion rules from other types (bytearray, str, int, float, Decimal) to bytes
   - There is NO documentation about limitations in JSON serialization for bytes fields
   - There is NO warning that bytes fields containing non-UTF-8 data will fail JSON serialization

2. **JSON Serialization Documentation**:
   - The .json() method documentation does not mention any special handling or limitations for bytes fields
   - No examples show bytes field serialization
   - No warnings about UTF-8 requirements for bytes fields

3. **Source Code Reality**:
   - The actual implementation in `/pydantic/v1/json.py` line 45 shows: `bytes: lambda o: o.decode()`
   - This assumes bytes can always be decoded as UTF-8 strings, which is incorrect for arbitrary binary data

### JSON Specification (RFC 8259)
1. **Binary Data Support**:
   - JSON does NOT natively support binary data
   - JSON strings must be valid Unicode and should be encoded in UTF-8
   - The specification does not provide guidance for representing arbitrary binary data

2. **Common Practices**:
   - The industry standard for representing binary data in JSON is base64 encoding
   - Many JSON APIs use base64 to encode binary data as strings

### Key Finding
There is a significant gap between:
- What pydantic v1 accepts (arbitrary bytes in the bytes field)
- What pydantic v1 documents (no warnings about JSON serialization limitations)
- What pydantic v1 actually does (attempts UTF-8 decode, causing crashes)
- What JSON supports (Unicode strings only, not arbitrary binary)

The documentation fails to warn users that bytes fields containing non-UTF-8 data cannot be serialized to JSON, despite this being a predictable failure mode given JSON's limitations.