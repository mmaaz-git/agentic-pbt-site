DOCUMENTATION ANALYSIS
======================

## Official Pydantic Documentation
The official Pydantic v1 documentation (https://docs.pydantic.dev/1.10/usage/types/#bytesize) provides minimal information about ByteSize:

1. Basic usage examples showing integer values and string parsing
2. Note that "1b will be parsed as '1 byte' and not '1 bit'"
3. Examples of human_readable() and to() methods
4. No explicit mention of fractional byte handling
5. No statement about whether fractional inputs are supported or not

## Code Analysis
From examining the source code:
1. ByteSize inherits from int (line 1092: class ByteSize(int))
2. The regex pattern accepts decimal numbers: r'^\s*(\d*\.?\d+)\s*(\w+)?'
3. The validate method explicitly converts to int: int(float(scalar) * unit_mult)

## Key Documentation Gaps
The documentation does NOT specify:
1. Whether fractional byte inputs (e.g., "0.5b") are valid
2. That ByteSize truncates fractional values to integers
3. That precision loss occurs for sub-byte values
4. The expected behavior for round-trip conversions with fractional inputs
5. That ByteSize must be an integer due to inheritance from int

## Examples in Documentation
The documentation examples only show:
- Integer direct values: MyModel(size=52000)
- String values that result in integers: '3000 KiB' -> 3072000
- Large values: '50 PB'
- The to() method returning floats: m.size.to('TiB') -> 45474.73508864641

Notably, no examples demonstrate fractional byte inputs like "0.5b".

## External Standards
The documentation mentions conformance with IEC 80000-13 Standard for binary/decimal prefixes, but this standard doesn't address fractional byte representation.

## Conclusion
The documentation is ambiguous about fractional byte handling. It neither explicitly allows nor forbids fractional inputs, creating uncertainty about the intended behavior. The regex pattern suggests fractional inputs are accepted, but the silent truncation behavior is undocumented.