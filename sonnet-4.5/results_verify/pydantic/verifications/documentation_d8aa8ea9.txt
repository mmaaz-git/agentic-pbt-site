## Documentation Analysis

### Experimental Pipeline Documentation

The pydantic experimental pipeline feature is marked as **experimental** and subject to change. The documentation is minimal and lacks detailed specifications.

### Key Documentation Points:

1. **Pipeline `otherwise` method** (line 327 of pipeline.py):
   - Documentation string: "Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails."
   - This clearly states that when the first chain "fails", it should fall back to the second chain
   - The documentation does NOT specify what constitutes "failure" - is it only ValidationError or any error?

2. **Implementation Details**:
   - The `otherwise` method creates a `_PipelineOr` object
   - `_PipelineOr` is converted to a `union_schema` in pydantic_core
   - Union schemas in pydantic are expected to try each member and collect errors

3. **Union Validation Behavior** (from Pydantic docs):
   - Union validation should attempt each member in order
   - If validation fails on all members, all errors are returned
   - The documentation states: "If validation failed on all the members, return all the errors"
   - There's no explicit statement about TypeErrors vs ValidationErrors

4. **Error Handling Guidelines** (from Pydantic docs):
   - "Validation code should not raise the ValidationError itself, but rather raise a ValueError or AssertionError"
   - This suggests that validation functions should raise ValueError, not allow TypeErrors to propagate

### Documentation Gaps:

1. The experimental pipeline documentation doesn't specify:
   - How type mismatches should be handled in constraint checks
   - Whether TypeErrors constitute a "failure" that triggers fallback
   - What specific exceptions should trigger the `otherwise` fallback

2. The behavior is ambiguous because:
   - Standard pydantic union validation expects ValidationErrors
   - The pipeline constraint checks can produce TypeErrors
   - There's no documented exception handling strategy for type mismatches

### Conclusion:

The documentation strongly implies that the `otherwise` operator should provide fallback behavior when validation "fails". A TypeError during constraint checking (e.g., comparing string >= int) is clearly a validation failure from a user perspective. The current behavior where TypeErrors crash validation entirely contradicts the documented purpose of the `otherwise` operator to "return the result of... the second chain if [the first] fails."