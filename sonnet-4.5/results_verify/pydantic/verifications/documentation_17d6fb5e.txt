## Documentation Analysis for Pydantic.v1 BaseModel Hash/Equality

### Pydantic Documentation Findings

After searching the official Pydantic v1.10 documentation at https://docs.pydantic.dev/1.10/, I found:

1. **No explicit documentation of equality behavior**: The Pydantic v1 documentation does not explicitly document how `__eq__` works for BaseModel instances. There is no mention that models of different classes with the same field values are considered equal.

2. **No documentation of hashing behavior**: The documentation does not describe how `__hash__` is implemented for frozen models, nor does it mention that the class type is included in the hash calculation.

3. **Frozen models are mentioned**: The documentation does mention that models can be made frozen (immutable) with `Config.frozen = True`, which enables hashing, but does not detail the implementation specifics.

### Python Language Documentation

According to Python's official documentation at https://docs.python.org/3/reference/datamodel.html#object.__hash__:

1. **Core requirement**: "The only required property is that objects which compare equal have the same hash value."

2. **Hash/equality contract**: If `a == b` returns True, then `hash(a)` must equal `hash(b)`. This is a fundamental requirement for Python objects that are both hashable and comparable.

3. **Consequences of violation**: Violating this contract leads to incorrect behavior in sets and dictionaries, as these data structures rely on the hash/equality invariant.

### Source Code Analysis

Looking at the pydantic/v1/main.py source code:

1. **`__eq__` implementation (lines 911-915)**: Compares only the `dict()` representation of models, completely ignoring the class type. This means `Model1(x=1) == Model2(x=1)` returns True even for different model classes.

2. **`generate_hash_function` (lines 102-106)**: Includes `hash(self.__class__)` in the hash calculation, making the hash dependent on the model class.

### Conclusion from Documentation

The behavior is **undocumented** in Pydantic's official documentation. Users have no way of knowing from the documentation that:
- Different model classes with the same data are considered equal
- The hash function includes the class type while equality does not

This undocumented behavior violates Python's fundamental hash/equality contract, which is a well-established requirement in Python's data model.