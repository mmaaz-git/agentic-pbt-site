## Bug Triage Analysis

### Consideration for BUG (Most Likely)

**Why it's a BUG:**
1. The `otherwise` operator's documented purpose is to provide fallback behavior, but it completely fails to do so when type mismatches occur
2. The behavior violates user expectations - when using `int_pipeline.otherwise(str_pipeline)` for a union type, users reasonably expect string inputs to fall back to the string pipeline
3. The crash with TypeError makes the `otherwise` operator essentially unusable for union type validation, which is one of its primary use cases
4. The fix is straightforward - catch TypeError in constraint checks and convert to ValueError
5. This is not an edge case - it's the normal, expected usage pattern for union validation

### Consideration for INVALID

**Why it might be INVALID:**
1. The code is marked as "experimental" with warnings that it may change
2. One could argue that TypeErrors indicate programming errors rather than validation failures
3. The documentation doesn't explicitly promise TypeError handling

**Counter-argument:** Even experimental features should work for their documented purpose. The `otherwise` operator is documented to provide fallback behavior, which it fails to do.

### Consideration for WONTFIX

**Why it might be WONTFIX:**
1. The feature is experimental and may be redesigned entirely
2. Users could work around this by using traditional union types instead
3. The maintainers might prefer to redesign the API rather than patch this issue

**Counter-argument:** This is a fundamental failure of the feature's core functionality, not an obscure edge case. Even experimental features should work for basic use cases.

### Consideration for FEATURE_REQUEST

**Why it might be FEATURE_REQUEST:**
1. One could argue that handling TypeErrors in constraint checks is a new feature
2. The current implementation might have been designed only for homogeneous type chains

**Counter-argument:** The `otherwise` operator explicitly returns a union type signature (`_InT | _OtherIn`), indicating it's designed for heterogeneous types. This isn't a new feature but a fix for broken existing functionality.

### Consideration for DOCUMENTATION_FIX

**Why it might be DOCUMENTATION_FIX:**
1. The documentation could be updated to warn that `otherwise` doesn't work with different types
2. The docs could specify that constraint checks must be type-compatible

**Counter-argument:** The code signature and documentation clearly indicate the feature is meant to work with union types. Documenting that it doesn't work would be documenting a bug, not clarifying intended behavior.

### Final Assessment

This is clearly a **BUG**. The `otherwise` operator is documented and type-hinted to work with union types, providing fallback behavior when the first validation chain "fails". A TypeError during constraint checking is undeniably a validation failure, yet instead of falling back to the alternative chain as documented, the entire validation crashes. This breaks the fundamental promise of the feature.

The experimental nature of the feature doesn't excuse core functionality being broken. Users who adopt experimental features still expect them to work as documented for basic use cases. The fix is also straightforward and localized, making this a clear bug that should be fixed rather than documented around or ignored.